{"version":3,"file":"static/js/173.6e903803.chunk.js","mappings":"ghCAsBM,SAAUA,EAAaC,GAC3B,GAAI,UAAUC,KAAKD,IAAU,qBAAqBC,KAAKD,GAAQ,CAC7D,MAAME,GAAOF,EAAMG,MAAM,GAAI,GAC7B,GAAIC,OAAOC,cAAcH,IAAQA,GAAO,GAAKA,EAAM,GAAK,GACtD,OAAOA,CAEX,CACA,OAvBF,SAAiBI,GACf,MACMC,GADc,IAAIC,aACEC,OAAOH,GAEjC,IAAII,EAAI,EACR,IAAK,MAAMC,KAAKJ,EACdG,GAAS,IAAJA,EAAUC,GAAK,GAAK,GAE3B,OAAOD,CACT,CAcSE,CAAQZ,EACjB,C,ICJKa,E,iBAAL,SAAKA,GACHA,EAAAA,EAAA,gBACAA,EAAAA,EAAA,gBACAA,EAAAA,EAAA,cACAA,EAAAA,EAAA,cACAA,EAAAA,EAAA,uBACAA,EAAAA,EAAA,uBACAA,EAAAA,EAAA,iBACAA,EAAAA,EAAA,yBACAA,EAAAA,EAAA,mBACAA,EAAAA,EAAA,eACAA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,qBACAA,EAAAA,EAAA,uBACAA,EAAAA,EAAA,iBACAA,EAAAA,EAAA,uBACAA,EAAAA,EAAA,0BACD,CAjBD,CAAKA,IAAAA,EAAU,KAmBf,MAAMC,EAAc,OAGpB,SAASC,EAAoBC,EAAUC,EAAUC,GAC/C,OAAOF,EAAGG,IAAI,CAACC,EAAGC,IAAMH,EAAEE,EAAGH,EAAGI,IAClC,CAKA,MAAMC,EAANC,WAAAA,GAEU,KAAAC,MAAsB,GACtB,KAAAC,KAAO,IAAIC,GAwCrB,CAtCSC,GAAAA,CAAIC,GACT,OAAOC,KAAKJ,KAAKE,IAAIC,EAAIE,KAC3B,CAEOC,GAAAA,CAAOC,EAAwBC,GACpC,MAAMC,EAAML,KAAKL,MAAMW,OACvBN,KAAKJ,KAAKW,IAAIJ,EAAKF,KAAMI,GACzBL,KAAKL,MAAMa,KAAKJ,EAClB,CAEOK,KAAAA,CAASV,EAAuBW,GACrC,MAAML,EAAML,KAAKJ,KAAKe,IAAIZ,EAAIE,MACxBW,EAAUZ,KAAKJ,KAAKe,IAAID,GAC9B,QAAYG,IAARR,EACF,MAAM,IAAIS,MAAM,0BAA4Bf,GAE9C,QAAgBc,IAAZD,EACF,MAAM,IAAIE,MAAM,0BAA4BJ,GAE9CV,KAAKL,MAAMU,GAAOL,KAAKL,MAAMiB,GAG7BZ,KAAKL,MAAMoB,OAAOH,EAAS,GAC3BZ,KAAKJ,KAAKoB,OAAON,EACnB,CAEO9B,MAAAA,GACL,MAAMqC,GAAMC,EAAAA,EAAAA,IAAUlB,KAAKL,MAAMW,QAC3BF,GAAMe,EAAAA,EAAAA,OAAUnB,KAAKL,OAC3B,OAAOwB,EAAAA,EAAAA,IAAOF,EAAKb,EACrB,CAEOgB,OAAAA,CAAQC,GACb,IAAKrB,KAAKJ,KAAKE,IAAIuB,GACjB,MAAM,IAAIP,MAAM,0BAA4BO,GAE9C,OAAOC,EAAAA,EAAAA,GAAWtB,KAAKJ,KAAKe,IAAIU,IAAa,EAC/C,EAGI,MAAgBE,EACbC,SAAAA,CAAaC,EAAaC,GAC/B,MAAM,IAAIZ,MAAM,kBAClB,CACOa,cAAAA,CAAkBC,EAAqBC,GAC5C,OAAO7B,KAAKwB,UAAUI,EAAGC,EAC3B,CACOC,UAAAA,CAAWF,EAAeC,GAC/B,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOE,SAAAA,CAAUH,EAAcC,GAC7B,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOG,SAAAA,CAAUJ,EAAcC,GAC7B,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOI,aAAAA,CAAcL,EAAkBC,GACrC,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOK,SAAAA,CAAUN,EAAcC,GAC7B,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOM,WAAAA,CAAeP,EAAqBC,GACzC,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOO,QAAAA,CAASR,EAAaC,GAC3B,OAAO7B,KAAKmC,YAAYP,EAAGC,EAC7B,CACOQ,QAAAA,CAAST,EAAaC,GAC3B,OAAO7B,KAAKmC,YAAYP,EAAGC,EAC7B,CACOS,UAAAA,CAAWV,EAAeC,GAC/B,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CACOU,aAAAA,CAAcX,EAAkBC,GACrC,OAAO7B,KAAKmC,YAAYP,EAAGC,EAC7B,CACOW,aAAAA,CAAcZ,EAAkBC,GACrC,OAAO7B,KAAKmC,YAAYP,EAAGC,EAC7B,CACOY,cAAAA,CAAeb,EAAmBC,GACvC,OAAO7B,KAAK2B,eAAeC,EAAGC,EAChC,CAEOa,cAAAA,CAAkBd,EAAqBC,GAC5C,OAAO7B,KAAKwB,UAAUI,EAAGC,EAC3B,CACOc,QAAAA,CAAYf,EAAgBgB,EAAcf,GAC/C,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,CACOgB,QAAAA,CAAYjB,EAAgBgB,EAAcf,GAC/C,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,CACOiB,WAAAA,CAAYlB,EAAgBmB,EAAgClB,GACjE,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,CACOmB,UAAAA,CAA4BpB,EAAkBqB,EAAoBpB,GACvE,MAAMqB,EAAgCD,EAAW3D,IAAI,CAAC6D,EAAI3D,IAAM,CAAC,IAAIA,KAAM2D,IAC3E,OAAOnD,KAAK8C,YAAYlB,EAAGsB,EAAQrB,EACrC,CACOuB,YAAAA,CAAaxB,EAAiBmB,EAAgClB,GACnE,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,CACOwB,QAAAA,CAAY5B,EAAiB0B,EAAsBtB,GACxD,OAAO7B,KAAK0C,eAAeS,EAAItB,EACjC,CACOyB,SAAAA,CAAU1B,EAAcC,GAC7B,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,CACO0B,YAAAA,CAAa3B,EAAiBC,GACnC,OAAO7B,KAAK0C,eAAed,EAAGC,EAChC,EAIF,IAAK2B,GAAL,SAAKA,GACHA,EAAA,gCACAA,EAAA,oCACAA,EAAA,8BACAA,EAAA,8BACAA,EAAA,sCACAA,EAAA,8BACAA,EAAA,4BACAA,EAAA,4BACAA,EAAA,gCACAA,EAAA,sCACAA,EAAA,sCACAA,EAAA,4BACAA,EAAA,4BACAA,EAAA,kCACAA,EAAA,gCACAA,EAAA,oCACAA,EAAA,4BACAA,EAAA,wCACAA,EAAA,8BACAA,EAAA,mCACD,CArBD,CAAKA,IAAAA,EAAW,KA0BV,MAAgBC,EAMbC,OAAAA,GACL,OAAO1D,KAAKC,IACd,CAEO0D,aAAAA,CAAcpE,GACnB,OAAOqE,EAAiBrE,EAC1B,CAGOsE,cAAAA,CAAeC,GACfA,EAAUhE,IAAIE,OACjBA,KAAK+D,oBAAoBD,EAE7B,EA4BI,MAAgBE,UAA+BP,EAC5CQ,SAAAA,CAAUrC,GACf,GAAI5B,KAAKC,OAAS2B,EAAE3B,KAClB,MAAM,IAAIa,MAAM,mCAAmCc,EAAE3B,qBAAqBD,KAAKC,QAEjF,OAAO2B,CACT,CAEOmC,mBAAAA,CAAoBG,GAG3B,EAGI,MAAgBC,UAA+BV,EAC5CQ,SAAAA,CAAUrC,GACf,GAAIA,aAAawC,EAAU,CACzB,MAAMjB,EAAKvB,EAAEyC,UACb,GAAkB,qBAAPlB,EACT,MAAM,IAAIrC,MAAM,yCAElB,OAAOqC,CACT,CACA,MAAM,IAAIrC,MAAM,mCAAmCc,EAAE3B,qBAAqBD,KAAKC,OACjF,CACOqE,UAAAA,CAAWR,GAChB,OAAOA,EAAU1C,QAAQpB,KAAKC,KAChC,EAQI,MAAOsE,UAAmBP,EAC9B,YAAI3C,GACF,OAAOmC,EAAYe,UACrB,CAEA,OAAQC,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYe,UAC3C,CAEOI,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE9C,WAAW9B,KAAM6E,EAC5B,CAEOC,SAAAA,CAAUvF,GACf,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,GACL,MAAM,IAAIjE,MAAM,6CAClB,CAEO6C,aAAAA,GACL,MAAM,IAAI7C,MAAM,iCAClB,CAEOwD,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWgG,MAC/B,CAEOC,WAAAA,GACL,MAAM,IAAInE,MAAM,mCAClB,CAEA,QAAIb,GACF,MAAO,OACT,EAUI,MAAOiF,UAAqBzB,EAChC,YAAIpC,GACF,OAAOmC,EAAY0B,YACrB,CAEA,OAAQV,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY0B,YAC3C,CAEOjB,SAAAA,CAAUxC,GACf,MAAM,IAAIX,MAAM,sCAClB,CAEO6D,MAAAA,CAAaC,EAAkBC,GACpC,MAAMD,EAAEpD,UAAUxB,KAAM6E,EAC1B,CAEOC,SAAAA,CAAUvF,GACf,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,GACL,MAAM,IAAIjE,MAAM,+CAClB,CAEO6C,aAAAA,GACL,MAAM,IAAI7C,MAAM,mCAClB,CAEOwD,UAAAA,GACL,MAAM,IAAIxD,MAAM,+BAClB,CAEOmE,WAAAA,CAAYE,EAASvD,GAC1B,IASIwD,EATAC,EAAezD,EAAEqD,YAAYE,EAAGvD,GAyBpC,OAvBI0D,OAAOD,KAAkBA,IAI3BA,EAAeC,OAAOD,IAKtBD,EADExD,aAAawC,EACJgB,IAAMxD,EAAEyC,UAERe,IAAMxD,EAMnB0D,OAAOC,eAAeF,EAAc,OAAQ,CAC1CG,MAAOJ,EACPK,UAAU,EACVC,YAAY,EACZC,cAAc,IAETN,CACT,CAEUtB,mBAAAA,GACR,MAAM,IAAIjD,MAAM,+BAClB,CAEA,QAAIb,GACF,MAAO,SACT,EAMI,MAAO2F,UAAkB5B,EAC7B,YAAI3C,GACF,OAAOmC,EAAYoC,SACrB,CAEA,OAAQpB,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYoC,SAC3C,CAEOjB,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE7C,UAAU/B,KAAM6E,EAC3B,CAEOC,SAAAA,CAAUvF,GACf,GAAiB,mBAANA,EAAiB,OAAO,EACnC,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAO,IAAIsG,WAAW,CAACtG,EAAI,EAAI,GACjC,CAEO+E,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAW8G,KAC/B,CAEOb,WAAAA,CAAYE,EAASvD,GAE1B,OADA5B,KAAKiE,UAAUrC,IACPmE,EAAAA,EAAAA,IAAcZ,IACpB,KAAK,EACH,OAAO,EACT,KAAK,EACH,OAAO,EACT,QACE,MAAM,IAAIrE,MAAM,8BAEtB,CAEA,QAAIb,GACF,MAAO,MACT,EAMI,MAAO+F,UAAkBhC,EAC7B,YAAI3C,GACF,OAAOmC,EAAYwC,SACrB,CAEA,OAAQxB,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYwC,SAC3C,CAEOrB,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE5C,UAAUhC,KAAM6E,EAC3B,CAEOC,SAAAA,CAAUvF,GACf,GAAU,OAANA,EAAY,OAAO,EACvB,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,GACL,OAAO,IAAIc,WAAW,EACxB,CAEOvB,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWiH,KAC/B,CAEOhB,WAAAA,CAAYiB,EAAUtE,GAE3B,OADA5B,KAAKiE,UAAUrC,GACR,IACT,CAEA,QAAI3B,GACF,MAAO,MACT,EAMI,MAAOkG,UAAsBnC,EACjC,YAAI3C,GACF,OAAOmC,EAAY2C,aACrB,CAEA,OAAQ3B,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY2C,aAC3C,CAEOxB,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE3C,cAAcjC,KAAM6E,EAC/B,CAEOC,SAAAA,CAAUsB,GACf,OAAO,CACT,CAEOrB,WAAAA,GACL,OAAO,IAAIc,WAAW,EACxB,CAEOvB,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWqH,SAC/B,CAEOpB,WAAAA,CAAYE,EAASvD,GAI1B,OAHIA,EAAE3B,OAASD,KAAKC,MAClB2B,EAAEqD,YAAYE,EAAGvD,GAEZ,IACT,CAEA,QAAI3B,GACF,MAAO,UACT,EAMI,MAAOqG,UAAkBtC,EAC7B,YAAI3C,GACF,OAAOmC,EAAY8C,SACrB,CAEA,OAAQ9B,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY8C,SAC3C,CAEO3B,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE1C,UAAUlC,KAAM6E,EAC3B,CAEOC,SAAAA,CAAUvF,GACf,GAAiB,kBAANA,EAAgB,OAAO,EAClC,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMa,GAAM,IAAIzB,aAAcC,OAAOW,GAC/B0B,GAAMC,EAAAA,EAAAA,IAAUd,EAAImG,YAC1B,OAAOpF,EAAAA,EAAAA,IAAOF,EAAKb,EACrB,CAEOkE,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWwH,KAC/B,CAEOvB,WAAAA,CAAYE,EAASvD,GAC1B5B,KAAKiE,UAAUrC,GACf,MAAMX,GAAMwF,EAAAA,EAAAA,IAAUtB,GAChB/E,GAAMsG,EAAAA,EAAAA,IAASvB,EAAG5G,OAAO0C,IAE/B,OADgB,IAAI0F,YAAY,OAAQ,CAAEC,OAAO,IAClCC,OAAOzG,EACxB,CAEA,QAAIH,GACF,MAAO,MACT,CAEO0D,aAAAA,CAAcpE,GACnB,MAAO,IAAMA,EAAI,GACnB,EAMI,MAAOuH,UAAiB9C,EAC5B,YAAI3C,GACF,OAAOmC,EAAYsD,QACrB,CAEA,OAAQtC,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYsD,QAC3C,CAEOnC,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAExC,SAASpC,KAAM6E,EAC1B,CAEOC,SAAAA,CAAUvF,GAGf,GAAiB,kBAANA,GAAkBhB,OAAOwI,UAAUxH,GAAI,OAAO,EACzD,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAO+B,EAAAA,EAAAA,GAAW/B,EACpB,CAEO+E,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWgI,IAC/B,CAEO/B,WAAAA,CAAYE,EAASvD,GAE1B,OADA5B,KAAKiE,UAAUrC,IACRqF,EAAAA,EAAAA,IAAW9B,EACpB,CAEA,QAAIlF,GACF,MAAO,KACT,CAEO0D,aAAAA,CAAcpE,GACnB,OAAOA,EAAE2H,UACX,EAMI,MAAOC,UAAiBnD,EAC5B,YAAI3C,GACF,OAAOmC,EAAY2D,QACrB,CAEA,OAAQ3C,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY2D,QAC3C,CAEOxC,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEvC,SAASrC,KAAM6E,EAC1B,CAEOC,SAAAA,CAAUvF,GAGf,GAAkB,kBAANA,GAAkBA,GAAK6H,OAAO,IAAQ7I,OAAOwI,UAAUxH,IAAMA,GAAK,EAAI,OAAO,EACzF,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAO2B,EAAAA,EAAAA,IAAU3B,EACnB,CAEO+E,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWqI,IAC/B,CAEOpC,WAAAA,CAAYE,EAASvD,GAE1B,OADA5B,KAAKiE,UAAUrC,IACR6E,EAAAA,EAAAA,IAAUtB,EACnB,CAEA,QAAIlF,GACF,MAAO,KACT,CAEO0D,aAAAA,CAAcpE,GACnB,OAAOA,EAAE2H,UACX,EAMI,MAAOI,UAAmBtD,EAC9B,YAAI3C,GACF,OAAOmC,EAAY8D,UACrB,CAEA,OAAQ9C,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY8D,UAC3C,CAEA5H,WAAAA,CAA4B6H,GAE1B,GADAC,QAD0B,KAAAD,MAAAA,EAEZ,KAAVA,GAA0B,KAAVA,EAClB,MAAM,IAAIzG,MAAM,yBAEpB,CACO6D,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEtC,WAAWtC,KAAM6E,EAC5B,CAEOC,SAAAA,CAAUvF,GACf,GAAiB,kBAANA,GAAkBA,aAAahB,OAAQ,OAAO,EACzD,MAAM,IAAIuC,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMa,EAAM,IAAIqH,YAAYzH,KAAKuH,MAAQ,GACnCG,EAAO,IAAIC,SAASvH,GAM1B,OALmB,KAAfJ,KAAKuH,MACPG,EAAKE,WAAW,EAAGrI,GAAG,GAEtBmI,EAAKG,WAAW,EAAGtI,GAAG,GAEjB,IAAIsG,WAAWzF,EACxB,CAEOkE,UAAAA,GACL,MAAMwD,EAAwB,KAAf9H,KAAKuH,MAAevI,EAAW+I,QAAU/I,EAAWgJ,QACnE,OAAO1G,EAAAA,EAAAA,GAAWwG,EACpB,CAEO7C,WAAAA,CAAYE,EAASvD,GAC1B5B,KAAKiE,UAAUrC,GACf,MAAMqG,GAAQvB,EAAAA,EAAAA,IAASvB,EAAGnF,KAAKuH,MAAQ,GACjCG,GAAOQ,EAAAA,EAAAA,IAAgBD,GAC7B,OAAmB,KAAfjI,KAAKuH,MACAG,EAAKS,WAAW,GAAG,GAEnBT,EAAKU,WAAW,GAAG,EAE9B,CAEA,QAAInI,GACF,MAAO,QAAUD,KAAKuH,KACxB,CAEO5D,aAAAA,CAAcpE,GACnB,OAAOA,EAAE2H,UACX,EAMI,MAAOmB,UAAsBrE,EACjC,YAAI3C,GACF,OAAOmC,EAAY6E,aACrB,CAEA,OAAQ7D,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY6E,aAC3C,CAEA3I,WAAAA,CAA4B6H,GAC1BC,QAD0B,KAAAD,MAAAA,CAE5B,CAEO5C,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAErC,cAAcvC,KAAM6E,EAC/B,CAEOC,SAAAA,CAAUvF,GACf,MAAM+I,GAAMC,EAAAA,EAAAA,GAAMvI,KAAKuH,MAAQ,GAAKH,QAAQ,GACtCoB,GAAMD,EAAAA,EAAAA,GAAMvI,KAAKuH,MAAQ,GAAKH,OAAO,GAC3C,IAAIqB,GAAK,EACT,GAAiB,kBAANlJ,EACTkJ,EAAKlJ,GAAK+I,GAAO/I,GAAKiJ,OACjB,GAAIjK,OAAOwI,UAAUxH,GAAI,CAC9B,MAAMqF,EAAIwC,OAAO7H,GACjBkJ,EAAK7D,GAAK0D,GAAO1D,GAAK4D,CACxB,MACEC,GAAK,EAGP,GAAIA,EAAI,OAAO,EACf,MAAM,IAAI3H,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAOmJ,EAAAA,EAAAA,IAAWnJ,EAAGS,KAAKuH,MAAQ,EACpC,CAEOjD,UAAAA,GACL,MAAMqE,EAASC,KAAKC,KAAK7I,KAAKuH,OAAS,EACvC,OAAOjG,EAAAA,EAAAA,IAAY,EAAIqH,EACzB,CAEO1D,WAAAA,CAAYE,EAASvD,GAC1B5B,KAAKiE,UAAUrC,GACf,MAAMvD,GAAMyK,EAAAA,EAAAA,IAAU3D,EAAGnF,KAAKuH,MAAQ,GACtC,OAAIvH,KAAKuH,OAAS,GACThJ,OAAOF,GAEPA,CAEX,CAEA,QAAI4B,GACF,MAAO,MAAMD,KAAKuH,OACpB,CAEO5D,aAAAA,CAAcpE,GACnB,OAAOA,EAAE2H,UACX,EAMI,MAAO6B,UAAsB/E,EACjC,YAAI3C,GACF,OAAOmC,EAAYuF,aACrB,CAEA,OAAQvE,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYuF,aAC3C,CAEArJ,WAAAA,CAA4B6H,GAC1BC,QAD0B,KAAAD,MAAAA,CAE5B,CAEO5C,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEpC,cAAcxC,KAAM6E,EAC/B,CAEOC,SAAAA,CAAUvF,GACf,MAAMiJ,GAAMD,EAAAA,EAAAA,GAAMvI,KAAKuH,OACvB,IAAIkB,GAAK,EACT,GAAiB,kBAANlJ,GAAkBA,GAAK6H,OAAO,GACvCqB,EAAKlJ,EAAIiJ,OACJ,GAAIjK,OAAOwI,UAAUxH,IAAMA,GAAK,EAAG,CAExCkJ,EADUrB,OAAO7H,GACRiJ,CACX,MACEC,GAAK,EAEP,GAAIA,EAAI,OAAO,EACf,MAAM,IAAI3H,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAOyJ,EAAAA,EAAAA,IAAYzJ,EAAGS,KAAKuH,MAAQ,EACrC,CAEOjD,UAAAA,GACL,MAAMqE,EAASC,KAAKC,KAAK7I,KAAKuH,OAAS,EACvC,OAAOjG,EAAAA,EAAAA,IAAY,EAAIqH,EACzB,CAEO1D,WAAAA,CAAYE,EAASvD,GAC1B5B,KAAKiE,UAAUrC,GACf,MAAMvD,GAAM4K,EAAAA,EAAAA,IAAW9D,EAAGnF,KAAKuH,MAAQ,GACvC,OAAIvH,KAAKuH,OAAS,GACThJ,OAAOF,GAEPA,CAEX,CAEA,QAAI4B,GACF,MAAO,MAAMD,KAAKuH,OACpB,CAEO5D,aAAAA,CAAcpE,GACnB,OAAOA,EAAE2H,UACX,EAUI,MAAOgC,UAAoB/E,EAC/B,YAAI9C,GACF,OAAOmC,EAAY0F,QACrB,CAEA,OAAQ1E,OAAOC,aAAgBC,GAC7B,OAAOA,EAASrD,WAAamC,EAAY0F,QAC3C,CAUAxJ,WAAAA,CAAmByJ,GACjB3B,QADiB,KAAA2B,MAAAA,EAFX,KAAAC,mBAAoB,EAItBD,aAAiBJ,GAAiC,IAAhBI,EAAM5B,QAC1CvH,KAAKoJ,mBAAoB,EAE7B,CAEOzE,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEjC,SAAS3C,KAAMA,KAAKmJ,MAAOtE,EACtC,CAEOC,SAAAA,CAAUvF,GAEf,MAAM8J,EACJrJ,KAAKmJ,iBAAiBJ,GAElB/I,KAAKmJ,iBAAiBd,EADtBrI,KAAKmJ,MAAM5B,MAGT,EAER,GACGE,YAAY6B,OAAO/J,IAAM8J,GAAuC,EAA9B9J,EAAUgK,mBAC5CC,MAAMC,QAAQlK,IACbA,EAAEmK,MAAM,CAAC9E,EAAGvE,KACV,IACE,OAAOL,KAAKmJ,MAAMrE,UAAUF,EAC9B,CAAE,MAAO+E,GACP,MAAM,IAAI7I,MAAM,WAAWd,KAAK0D,iCAAiCrD,QAAUsJ,EAAEC,UAC/E,IAGJ,OAAO,EAET,MAAM,IAAI9I,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAM0B,GAAMC,EAAAA,EAAAA,IAAU3B,EAAEe,QACxB,GAAIN,KAAKoJ,kBACP,OAAOjI,EAAAA,EAAAA,IAAOF,EAAK,IAAI4E,WAAWtG,IAGpC,GAAIkI,YAAY6B,OAAO/J,GAAI,CAEzB,GAAIA,aAAasK,YAActK,aAAauK,YAAa,CACvD,MAAMC,EAAS,IAAIpC,SAAS,IAAIF,YAAuB,EAAXlI,EAAEe,SAC9C,IAAK,IAAId,EAAI,EAAGA,EAAID,EAAEe,OAAQd,IACxBD,aAAasK,WACfE,EAAOC,SAAa,EAAJxK,EAAOD,EAAEC,IAAI,GAE7BuK,EAAOE,UAAc,EAAJzK,EAAOD,EAAEC,IAAI,GAGlC,OAAO2B,EAAAA,EAAAA,IAAOF,EAAK,IAAI4E,WAAWkE,EAAOA,QAC3C,CAAO,GAAIxK,aAAa2K,YAAc3K,aAAa4K,YAAa,CAC9D,MAAMJ,EAAS,IAAIpC,SAAS,IAAIF,YAAuB,EAAXlI,EAAEe,SAC9C,IAAK,IAAId,EAAI,EAAGA,EAAID,EAAEe,OAAQd,IACxBD,aAAa2K,WACfH,EAAOK,SAAa,EAAJ5K,EAAOD,EAAEC,IAAI,GAE7BuK,EAAOM,UAAc,EAAJ7K,EAAOD,EAAEC,IAAI,GAGlC,OAAO2B,EAAAA,EAAAA,IAAOF,EAAK,IAAI4E,WAAWkE,EAAOA,QAC3C,CAAO,GAAIxK,aAAa+K,eAAiB/K,aAAagL,eAAgB,CACpE,MAAMR,EAAS,IAAIpC,SAAS,IAAIF,YAAuB,EAAXlI,EAAEe,SAC9C,IAAK,IAAId,EAAI,EAAGA,EAAID,EAAEe,OAAQd,IACxBD,aAAa+K,cACfP,EAAOS,YAAgB,EAAJhL,EAAOD,EAAEC,IAAI,GAEhCuK,EAAOU,aAAiB,EAAJjL,EAAOD,EAAEC,IAAI,GAGrC,OAAO2B,EAAAA,EAAAA,IAAOF,EAAK,IAAI4E,WAAWkE,EAAOA,QAC3C,CAEE,OAAO5I,EAAAA,EAAAA,IAAOF,EAAK,IAAI4E,WAAWtG,EAAEwK,OAAQxK,EAAEmL,WAAYnL,EAAEgH,YAEhE,CACA,MAAMnG,EAAM,IAAIuK,EAAAA,GAAK,IAAI9E,WAAW5E,EAAIsF,WAAahH,EAAEe,QAAS,GAChEF,EAAIwK,MAAM3J,GACV,IAAK,MAAM4D,KAAKtF,EAAG,CACjB,MAAMsL,EAAU7K,KAAKmJ,MAAMpE,YAAYF,GACvCzE,EAAIwK,MAAM,IAAI/E,WAAWgF,GAC3B,CACA,OAAOzK,EAAI2J,MACb,CAEOhG,mBAAAA,CAAoBD,GACzB9D,KAAKmJ,MAAMtF,eAAeC,GAE1B,MAAMgH,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAW+L,QAC/BhB,EAAS/J,KAAKmJ,MAAM7E,WAAWR,GACrCA,EAAU5D,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQf,GACrC,CAEO9E,WAAAA,CAAYE,EAASvD,GAC1B,MAAMoJ,EAAMhL,KAAKiE,UAAUrC,GAC3B,KAAMoJ,aAAe9B,GACnB,MAAM,IAAIpI,MAAM,qBAElB,MAAMG,EAAM1C,QAAOkI,EAAAA,EAAAA,IAAUtB,IAE7B,GAAInF,KAAKmJ,iBAAiBJ,EAAe,CACvC,GAAwB,GAApB/I,KAAKmJ,MAAM5B,MACb,OAAO,IAAI1B,WAAWV,EAAE8F,KAAKhK,IAE/B,GAAwB,IAApBjB,KAAKmJ,MAAM5B,MAAa,CAC1B,MAAMU,EAAQ9C,EAAE8F,KAAW,EAANhK,GAGrB,OADY,IAAI6I,YAAY7B,EAAM8B,OAAQ9B,EAAMyC,WAAYzJ,EAE9D,CACA,GAAwB,IAApBjB,KAAKmJ,MAAM5B,MAAa,CAC1B,MAAMU,EAAQ9C,EAAE8F,KAAW,EAANhK,GAErB,OADY,IAAIkJ,YAAYlC,EAAM8B,OAAQ9B,EAAMyC,WAAYzJ,EAE9D,CACA,GAAwB,IAApBjB,KAAKmJ,MAAM5B,MACb,OAAO,IAAIgD,eAAepF,EAAE8F,KAAW,EAANhK,GAAS8I,OAE9C,CAEA,GAAI/J,KAAKmJ,iBAAiBd,EAAe,CACvC,GAAwB,GAApBrI,KAAKmJ,MAAM5B,MACb,OAAO,IAAI2D,UAAU/F,EAAE8F,KAAKhK,IAE9B,GAAwB,IAApBjB,KAAKmJ,MAAM5B,MAAa,CAC1B,MAAMU,EAAQ9C,EAAE8F,KAAW,EAANhK,GAEfyG,EAAO,IAAIC,SAASM,EAAM8B,OAAQ9B,EAAMyC,WAAYzC,EAAM1B,YAG1D4E,EAAS,IAAItB,WAAW5I,GAC9B,IAAK,IAAIzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAEvB2L,EAAO3L,GAAKkI,EAAK0D,SAAa,EAAJ5L,GAAO,GAEnC,OAAO2L,CACT,CACA,GAAwB,IAApBnL,KAAKmJ,MAAM5B,MAAa,CAC1B,MAAMU,EAAQ9C,EAAE8F,KAAW,EAANhK,GACfyG,EAAO,IAAIC,SAASM,EAAM8B,OAAQ9B,EAAMyC,WAAYzC,EAAM1B,YAE1D4E,EAAS,IAAIjB,WAAWjJ,GAC9B,IAAK,IAAIzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB2L,EAAO3L,GAAKkI,EAAK2D,SAAa,EAAJ7L,GAAO,GAEnC,OAAO2L,CACT,CACA,GAAwB,IAApBnL,KAAKmJ,MAAM5B,MAAa,CAC1B,MAAMU,EAAQ9C,EAAE8F,KAAW,EAANhK,GACfyG,EAAO,IAAIC,SAASM,EAAM8B,OAAQ9B,EAAMyC,WAAYzC,EAAM1B,YAE1D4E,EAAS,IAAIb,cAAcrJ,GACjC,IAAK,IAAIzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB2L,EAAO3L,GAAKkI,EAAK4D,YAAgB,EAAJ9L,GAAO,GAEtC,OAAO2L,CACT,CACF,CAEA,MAAMI,EAAY,GAClB,IAAK,IAAI/L,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB+L,EAAK/K,KAAKR,KAAKmJ,MAAMlE,YAAYE,EAAG6F,EAAI7B,QAE1C,OAAOoC,CACT,CAEA,QAAItL,GACF,MAAO,OAAOD,KAAKmJ,MAAMlJ,MAC3B,CAEOyD,OAAAA,GACL,MAAO,OAAO1D,KAAKmJ,MAAMzF,WAC3B,CAEOC,aAAAA,CAAcpE,GAEnB,MAAO,QADUA,EAAED,IAAIqK,GAAK3J,KAAKmJ,MAAMxF,cAAcgG,IAC3B6B,KAAK,MAAQ,GACzC,EAOI,MAAOC,UAAoBtH,EAC/B,YAAI9C,GACF,OAAOmC,EAAYiI,QACrB,CAEA,OAAQjH,OAAOC,aAAgBC,GAC7B,OAAOA,EAASrD,WAAamC,EAAYiI,QAC3C,CAEA/L,WAAAA,CAAmByJ,GACjB3B,QADiB,KAAA2B,MAAAA,CAEnB,CAEOxE,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE/B,SAAS7C,KAAMA,KAAKmJ,MAAOtE,EACtC,CAEOC,SAAAA,CAAUvF,GACf,IACE,GAAIiK,MAAMC,QAAQlK,KAAoB,IAAbA,EAAEe,QAA8B,IAAbf,EAAEe,QAAgBN,KAAKmJ,MAAMrE,UAAUvF,EAAE,KACnF,OAAO,CACX,CAAE,MAAOoK,GACP,MAAM,IAAI7I,MACR,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,aAAaoK,EAAEC,UAE3E,CACA,MAAM,IAAI9I,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,OAAiB,IAAbA,EAAEe,OACG,IAAIuF,WAAW,CAAC,KAEhB1E,EAAAA,EAAAA,IAAO,IAAI0E,WAAW,CAAC,IAAK7F,KAAKmJ,MAAMpE,YAAYxF,EAAE,IAEhE,CAEOwE,mBAAAA,CAAoBD,GACzB9D,KAAKmJ,MAAMtF,eAAeC,GAE1B,MAAMgH,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAW0M,KAC/B3B,EAAS/J,KAAKmJ,MAAM7E,WAAWR,GACrCA,EAAU5D,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQf,GACrC,CAEO9E,WAAAA,CAAYE,EAASvD,GAC1B,GAAIA,aAAaoE,EACf,MAAO,GAGT,GAAIpE,aAAauE,EACf,MAAO,GAGT,IAAIwF,EAAW/J,EAEf,GAAIA,aAAawC,EAAU,CACzB,MAAMjB,EAAKvB,EAAEyC,UACb,GAAkB,qBAAPlB,EACT,MAAM,IAAIrC,MAAM,yCACX6K,EAAWxI,CACpB,CAEA,GAAIwI,aAAoBF,EACtB,QAAQ1F,EAAAA,EAAAA,IAAcZ,IACpB,KAAK,EACH,MAAO,GACT,KAAK,EAAG,CAEN,MAAMyG,EAAazG,EAAE0G,OACrB,IAGE,MAAO,CADG7L,KAAKmJ,MAAMlE,YAAYE,EAAGwG,EAASxC,OAE/C,CAAE,MAAOQ,GAMP,OAJAxE,EAAE2G,QAAQF,GAEVD,EAASxC,MAAMlE,YAAYE,EAAGwG,EAASxC,OAEhC,EACT,CACF,CACA,QACE,MAAM,IAAIrI,MAAM,2BAEf,IAELd,KAAKmJ,iBAAiBnD,GACtBhG,KAAKmJ,iBAAiBsC,GACtBzL,KAAKmJ,iBAAiBhD,EAKtB,OADAwF,EAAS1G,YAAYE,EAAGwG,GACjB,GACF,CAGL,MAAMC,EAAazG,EAAE0G,OACrB,IAEE,MAAO,CADG7L,KAAKmJ,MAAMlE,YAAYE,EAAGvD,GAEtC,CAAE,MAAO+H,GAMP,OAJAxE,EAAE2G,QAAQF,GAEVD,EAAS1G,YAAYE,EAAGvD,GAEjB,EACT,CACF,EACF,CAEA,QAAI3B,GACF,MAAO,OAAOD,KAAKmJ,MAAMlJ,MAC3B,CAEOyD,OAAAA,GACL,MAAO,OAAO1D,KAAKmJ,MAAMzF,WAC3B,CAEOC,aAAAA,CAAcpE,GACnB,OAAiB,IAAbA,EAAEe,OACG,OAEA,OAAON,KAAKmJ,MAAMxF,cAAcpE,EAAE,KAE7C,EAOI,MAAOwM,UAAoB5H,EAC/B,YAAI9C,GACF,OAAOmC,EAAYuI,WACrB,CAEA,OAAQvH,OAAOC,aAAaC,GAE1B,OACEA,EAASrD,WAAamC,EAAYuI,aAAerH,EAASrD,WAAamC,EAAYwI,UAEvF,CAIAtM,WAAAA,GAA6C,IAAjCwD,EAAA+I,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAA+B,CAAC,EAC1CzE,QACAxH,KAAK+C,QAAUuC,OAAO4G,QAAQhJ,GAAQiJ,KAAK,CAACC,EAAGjH,IAAMjH,EAAakO,EAAE,IAAMlO,EAAaiH,EAAE,IAC3F,CAEOR,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE9B,YAAY9C,KAAMA,KAAK+C,QAAS8B,EAC3C,CAEOwH,UAAAA,GACL,MAAMC,EAAc,GACpB,IAAK,IAAI9M,EAAI,EAAGA,EAAIQ,KAAK+C,QAAQzC,OAAQd,IAAK,CAC5C,MAAO+M,EAAKpM,GAAQH,KAAK+C,QAAQvD,GACjC,GAAI+M,IAAQ,IAAI/M,KACd,OAAO,KAET8M,EAAI9L,KAAKL,EACX,CACA,OAAOmM,CACT,CAEOxH,SAAAA,CAAUvF,GACf,GACe,kBAANA,GACPS,KAAK+C,QAAQ2G,MAAM8C,IAAW,IAATC,EAAG7K,GAAE4K,EAExB,IAAKjN,EAAEmN,eAAeD,GACpB,MAAM,IAAI3L,MAAM,0BAA0B2L,OAE5C,IACE,OAAO7K,EAAEkD,UAAUvF,EAAEkN,GACvB,CAAE,MAAO9C,GACP,MAAM,IAAI7I,MAAM,WAAWd,KAAK0D,iCAAiC+I,QAAQ9C,EAAEC,UAC7E,IAGF,OAAO,EAET,MAAM,IAAI9I,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMoN,EAAS3M,KAAK+C,QAAQzD,IAAIsN,IAAA,IAAEL,GAAIK,EAAA,OAAKrN,EAAEgN,KACvCM,EAAO3N,EAAQc,KAAK+C,QAAS4J,EAAQ,CAAAG,EAAQjI,KAAC,IAAP,CAAE/F,GAAEgO,EAAA,OAAQhO,EAAEiG,YAAYF,KACvE,OAAO1D,EAAAA,EAAAA,OAAU0L,EACnB,CAEO9I,mBAAAA,CAAoBgJ,GACzB/M,KAAK+C,QAAQiK,QAAQC,IAAA,IAAEC,EAAG1H,GAAMyH,EAAA,OAAKzH,EAAM3B,eAAekJ,KAC1D,MAAMjC,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAWmO,QAC/BlM,GAAMC,EAAAA,EAAAA,IAAUlB,KAAK+C,QAAQzC,QAC7B4C,EAASlD,KAAK+C,QAAQzD,IAAI8N,IAAA,IAAEb,EAAK/G,GAAM4H,EAAA,OAC3CjM,EAAAA,EAAAA,KAAOD,EAAAA,EAAAA,IAAUhD,EAAaqO,IAAO/G,EAAMlB,WAAWyI,MAGxDA,EAAE7M,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQ7J,GAAKE,EAAAA,EAAAA,OAAU+B,IAC5C,CAEO+B,WAAAA,CAAYE,EAASvD,GAC1B,MAAMyL,EAASrN,KAAKiE,UAAUrC,GAC9B,KAAMyL,aAAkBtB,GACtB,MAAM,IAAIjL,MAAM,qBAElB,MAAMvB,EAAyB,CAAC,EAEhC,IAAI+N,EAAoB,EACpBC,EAAkB,EACtB,KAAOA,EAAkBF,EAAOtK,QAAQzC,QAAQ,CAC9C,MAAOkN,EAAMrN,GAAQkN,EAAOtK,QAAQwK,GAEpC,GAAID,GAAqBtN,KAAK+C,QAAQzC,OAAQ,CAE5CH,EAAK8E,YAAYE,EAAGhF,GACpBoN,IACA,QACF,CAEA,MAAOE,EAAWC,GAAc1N,KAAK+C,QAAQuK,GACvCK,EAAazP,EAAa8B,KAAK+C,QAAQuK,GAAmB,IAC1DM,EAAW1P,EAAasP,GAC9B,GAAIG,IAAeC,EAEjBrO,EAAEkO,GAAaC,EAAWzI,YAAYE,EAAGhF,GACzCmN,IACAC,SACK,GAAIK,EAAWD,EAAY,CAEhC,KAAID,aAAsBjC,GAAYiC,aAAsBvH,GAI1D,MAAM,IAAIrF,MAAM,8BAAgC2M,GAHhDlO,EAAEkO,GAAa,GACfH,GAIJ,MAEEnN,EAAK8E,YAAYE,EAAGhF,GACpBoN,GAEJ,CAGA,IAAK,MAAOE,EAAWC,KAAe1N,KAAK+C,QAAQzE,MAAMgP,GAAoB,CAC3E,KAAII,aAAsBjC,GAAYiC,aAAsBvH,GAI1D,MAAM,IAAIrF,MAAM,8BAAgC2M,GAFhDlO,EAAEkO,GAAa,EAInB,CACA,OAAOlO,CACT,CAEA,kBAAIsO,GACF,MAAM3K,EAA+B,CAAC,EACtC,IAAK,MAAOjD,EAAMkD,KAAOnD,KAAK+C,QAC5BG,EAAOhF,EAAa+B,IAASkD,EAE/B,OAAOD,CACT,CAEA,QAAIjD,GAEF,MAAO,WADQD,KAAK+C,QAAQzD,IAAIwO,IAAA,IAAEvB,EAAK/G,GAAMsI,EAAA,OAAKvB,EAAM,IAAM/G,EAAMvF,OAC3CuL,KAAK,QAChC,CAEO9H,OAAAA,GAEL,MAAO,WADQ1D,KAAK+C,QAAQzD,IAAIyO,IAAA,IAAExB,EAAK/G,GAAMuI,EAAA,OAAKxB,EAAM,IAAM/G,EAAM9B,YAC3C8H,KAAK,QAChC,CAEO7H,aAAAA,CAAcpE,GACnB,MAAMoN,EAAS3M,KAAK+C,QAAQzD,IAAI0O,IAAA,IAAEzB,GAAIyB,EAAA,OAAKzO,EAAEgN,KAE7C,MAAO,WADQrN,EAAQc,KAAK+C,QAAS4J,EAAQ,CAAAsB,EAASpJ,KAAC,IAAR4H,EAAG3N,GAAEmP,EAAA,OAAQxB,EAAI,IAAM3N,EAAE6E,cAAckB,KAC7D2G,KAAK,QAChC,EAOI,MAAOQ,UAAoCD,EAC/C,YAAI1K,GACF,OAAOmC,EAAYwI,UACrB,CAEA,OAAQxH,OAAOC,aAA8BC,GAC3C,OAAOA,EAASrD,WAAamC,EAAYwI,UAC3C,CAIAtM,WAAAA,CAAYwO,GACV,MAAM3O,EAAyB,CAAC,EAChC2O,EAAYlB,QAAQ,CAACrD,EAAGnK,IAAOD,EAAE,IAAMC,EAAI,KAAOmK,GAClDnC,MAAMjI,GACNS,KAAKkO,YAAcA,CACrB,CAEOvJ,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAE5B,WAAWhD,KAAMA,KAAKkO,YAAarJ,EAC9C,CAEOC,SAAAA,CAAUvF,GAGf,GACEiK,MAAMC,QAAQlK,IACdA,EAAEe,QAAUN,KAAK+C,QAAQzC,QACzBN,KAAKkO,YAAYxE,MAAM,CAAC9H,EAAGpC,KACzB,IACE,OAAOoC,EAAEkD,UAAUvF,EAAEC,GACvB,CAAE,MAAOmK,GACP,MAAM,IAAI7I,MAAM,WAAWd,KAAK0D,iCAAiClE,QAAQmK,EAAEC,UAC7E,IAGF,OAAO,EAET,MAAM,IAAI9I,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMsN,EAAO3N,EAAQc,KAAKkO,YAAa3O,EAAG,CAACT,EAAG+F,IAAM/F,EAAEiG,YAAYF,IAClE,OAAO1D,EAAAA,EAAAA,OAAU0L,EACnB,CAEO5H,WAAAA,CAAYE,EAASvD,GAC1B,MAAMuM,EAAQnO,KAAKiE,UAAUrC,GAC7B,KAAMuM,aAAiBnC,GACrB,MAAM,IAAIlL,MAAM,oBAElB,GAAIqN,EAAMD,YAAY5N,OAASN,KAAKkO,YAAY5N,OAC9C,MAAM,IAAIQ,MAAM,kBAElB,MAAMwL,EAAM,GACZ,IAAK,MAAO9M,EAAGmM,KAAawC,EAAMD,YAAYhC,UACxC1M,GAAKQ,KAAKkO,YAAY5N,OAExBqL,EAAS1G,YAAYE,EAAGwG,GAExBW,EAAI9L,KAAKR,KAAKkO,YAAY1O,GAAGyF,YAAYE,EAAGwG,IAGhD,OAAOW,CACT,CAEO5I,OAAAA,GAEL,MAAO,WADQ1D,KAAKkO,YAAY5O,IAAIkG,GAASA,EAAM9B,WAC1B8H,KAAK,QAChC,CAEO7H,aAAAA,CAAcgJ,GAEnB,MAAO,WADQzN,EAAQc,KAAKkO,YAAavB,EAAQ,CAAC7N,EAAG+F,IAAM/F,EAAE6E,cAAckB,IAClD2G,KAAK,QAChC,EAOI,MAAO4C,UAAqBjK,EAChC,YAAI9C,GACF,OAAOmC,EAAY4K,YACrB,CAEA,OAAQ5J,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY4K,YAC3C,CAIA1O,WAAAA,GAA6C,IAAjCwD,EAAA+I,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAA+B,CAAC,EAC1CzE,QACAxH,KAAK+C,QAAUuC,OAAO4G,QAAQhJ,GAAQiJ,KAAK,CAACC,EAAGjH,IAAMjH,EAAakO,EAAE,IAAMlO,EAAaiH,EAAE,IAC3F,CAEOR,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAExB,aAAapD,KAAMA,KAAK+C,QAAS8B,EAC5C,CAEOC,SAAAA,CAAUvF,GACf,GACe,kBAANA,GACsB,IAA7B+F,OAAO4G,QAAQ3M,GAAGe,QAClBN,KAAK+C,QAAQ2G,MAAM2E,IAAW,IAAT5B,EAAG7H,GAAEyJ,EACxB,IAEE,OAAQ9O,EAAEmN,eAAeD,IAAM7H,EAAEE,UAAUvF,EAAEkN,GAC/C,CAAE,MAAO9C,GACP,MAAM,IAAI7I,MAAM,WAAWd,KAAK0D,mCAAmC+I,QAAQ9C,EAAEC,UAC/E,IAGF,OAAO,EAET,MAAM,IAAI9I,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIQ,KAAK+C,QAAQzC,OAAQd,IAAK,CAC5C,MAAOS,EAAME,GAAQH,KAAK+C,QAAQvD,GAElC,GAAID,EAAEmN,eAAezM,GAAO,CAC1B,MAAMI,GAAMa,EAAAA,EAAAA,IAAU1B,GAChBY,EAAMD,EAAK4E,YAAYxF,EAAEU,IAE/B,OAAOkB,EAAAA,EAAAA,IAAOd,EAAKD,EACrB,CACF,CACA,MAAMU,MAAM,wBAA0BvB,EACxC,CAEOwE,mBAAAA,CAAoBD,GACzB9D,KAAK+C,QAAQiK,QAAQsB,IAAa,IAAX,CAAEnO,GAAKmO,EAC5BnO,EAAK0D,eAAeC,KAEtB,MAAMgH,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAWuP,SAC/BtN,GAAMC,EAAAA,EAAAA,IAAUlB,KAAK+C,QAAQzC,QAC7B4C,EAASlD,KAAK+C,QAAQzD,IAAIkP,IAAA,IAAEjC,EAAK/G,GAAMgJ,EAAA,OAC3CrN,EAAAA,EAAAA,KAAOD,EAAAA,EAAAA,IAAUhD,EAAaqO,IAAO/G,EAAMlB,WAAWR,MAExDA,EAAU5D,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQ7J,KAAQiC,GAC7C,CAEO+B,WAAAA,CAAYE,EAASvD,GAC1B,MAAM6M,EAAUzO,KAAKiE,UAAUrC,GAC/B,KAAM6M,aAAmBL,GACvB,MAAM,IAAItN,MAAM,sBAElB,MAAMT,EAAM9B,QAAOkI,EAAAA,EAAAA,IAAUtB,IAC7B,GAAI9E,GAAOoO,EAAQ1L,QAAQzC,OACzB,MAAMQ,MAAM,0BAA4BT,GAE1C,MAAOqO,EAAU/C,GAAY8C,EAAQ1L,QAAQ1C,GAC7C,IAAK,MAAOkM,EAAKmB,KAAe1N,KAAK+C,QACnC,GAAI7E,EAAawQ,KAAcxQ,EAAaqO,GAAM,CAChD,MAAM/G,EAAQkI,EAAWzI,YAAYE,EAAGwG,GACxC,MAAO,CAAE,CAACY,GAAM/G,EAClB,CAEF,MAAM,IAAI1E,MAAM,0BAA4B4N,EAC9C,CAEA,QAAIzO,GAEF,MAAO,YADQD,KAAK+C,QAAQzD,IAAIqP,IAAA,IAAEpC,EAAKpM,GAAKwO,EAAA,OAAKpC,EAAM,IAAMpM,EAAKF,OACxCuL,KAAK,QACjC,CAEO9H,OAAAA,GAIL,MAAO,YAHQ1D,KAAK+C,QAAQzD,IAC1BsP,IAAA,IAAErC,EAAKpM,GAAKyO,EAAA,OAAKrC,GAAqB,SAAdpM,EAAKF,KAAkB,GAAK,IAAIE,EAAKuD,eAErC8H,KAAK,QACjC,CAEO7H,aAAAA,CAAcpE,GACnB,IAAK,MAAOU,EAAME,KAASH,KAAK+C,QAE9B,GAAIxD,EAAEmN,eAAezM,GAAO,CAC1B,MAAMuF,EAAQrF,EAAKwD,cAAcpE,EAAEU,IACnC,MAAc,SAAVuF,EACK,YAAYvF,KAEZ,YAAYA,KAAQuF,IAE/B,CAEF,MAAM,IAAI1E,MAAM,wBAA0BvB,EAC5C,CAEA,wBAAIsP,GACF,MAAMC,EAAqC,CAAC,EAC5C,IAAK,MAAO7O,EAAMkD,KAAOnD,KAAK+C,QAC5B+L,EAAa5Q,EAAa+B,IAASkD,EAErC,OAAO2L,CACT,EAOI,MAAO1K,UAA0BD,EAAvCzE,WAAAA,G,oBAMU,KAAAqP,IAAM3K,EAAS4K,UAmEzB,CAxEE,YAAI3N,GACF,OAAOmC,EAAYY,QACrB,CAAC,cAEc,KAAA4K,SAAW,EAFzB,GAMD,OAAQxK,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYY,QAC3C,CAEOO,MAAAA,CAAaC,EAAkBC,GACpC,IAAK7E,KAAKmJ,MACR,MAAMrI,MAAM,iCAEd,OAAO8D,EAAEvB,SAASrD,KAAMA,KAAKmJ,MAAOtE,EACtC,CAEOoK,IAAAA,CAAKrN,GACV5B,KAAKmJ,MAAQvH,CACf,CAEOyC,OAAAA,GACL,OAAOrE,KAAKmJ,KACd,CAEOrE,SAAAA,CAAUvF,GACf,GAAIS,KAAKmJ,OAAQnJ,KAAKmJ,MAAMrE,UAAUvF,GAAY,OAAO,EACzD,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,IAAKS,KAAKmJ,MACR,MAAMrI,MAAM,iCAEd,OAAOd,KAAKmJ,MAAMpE,YAAYxF,EAChC,CAEOwE,mBAAAA,CAAoBD,GACzB,IAAK9D,KAAKmJ,MACR,MAAMrI,MAAM,iCAEdgD,EAAU5D,IAAIF,KAAM,IAAI6F,WAAW,KACnC7F,KAAKmJ,MAAMtF,eAAeC,GAC1BA,EAAUrD,MAAMT,KAAMA,KAAKmJ,MAAMlJ,KACnC,CAEOgF,WAAAA,CAAYE,EAASvD,GAC1B,IAAK5B,KAAKmJ,MACR,MAAMrI,MAAM,iCAEd,OAAOd,KAAKmJ,MAAMlE,YAAYE,EAAGvD,EACnC,CAEA,QAAI3B,GACF,MAAO,OAAOD,KAAK+O,KACrB,CAEOrL,OAAAA,GACL,IAAK1D,KAAKmJ,MACR,MAAMrI,MAAM,iCAEd,MAAO,SAAId,KAAKC,QAAQD,KAAKmJ,MAAMlJ,MACrC,CAEO0D,aAAAA,CAAcpE,GACnB,IAAKS,KAAKmJ,MACR,MAAMrI,MAAM,iCAEd,OAAOd,KAAKmJ,MAAMxF,cAAcpE,EAClC,EAGF,SAAS2P,EAAkB/J,GAEzB,GAAU,KADAY,EAAAA,EAAAA,IAAcZ,GAEtB,MAAM,IAAIrE,MAAM,2BAGlB,MAAMG,EAAM1C,QAAOkI,EAAAA,EAAAA,IAAUtB,IAC7B,OAAOgK,EAAAA,EAAYC,eAAe,IAAIvJ,YAAWa,EAAAA,EAAAA,IAASvB,EAAGlE,IAC/D,CAKM,MAAOoO,UAAuBrL,EAClC,YAAI3C,GACF,OAAOmC,EAAY6L,cACrB,CAEA,OAAQ7K,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY6L,cAC3C,CAEO1K,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEnC,eAAezC,KAAM6E,EAChC,CAEOC,SAAAA,CAAUvF,GACf,GAAIA,GAAKA,EAAE+P,aAAc,OAAO,EAChC,MAAM,IAAIxO,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMa,EAAMb,EAAEgQ,eACRtO,GAAMC,EAAAA,EAAAA,IAAUd,EAAImG,YAC1B,OAAOpF,EAAAA,EAAAA,IAAO,IAAI0E,WAAW,CAAC,IAAK5E,EAAKb,EAC1C,CACOkE,UAAAA,GACL,OAAOhD,EAAAA,EAAAA,GAAWtC,EAAWwQ,UAC/B,CAEOvK,WAAAA,CAAYE,EAASvD,GAE1B,OADA5B,KAAKiE,UAAUrC,GACRsN,EAAkB/J,EAC3B,CAEA,QAAIlF,GACF,MAAO,WACT,CACO0D,aAAAA,CAAcpE,GACnB,MAAO,GAAGS,KAAKC,SAASV,EAAEkQ,WAC5B,EASI,MAAOC,UAAkBvL,EAC7B,YAAI9C,GACF,OAAOmC,EAAYkM,SACrB,CAEA,OAAQlL,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAYkM,SAC3C,CAEO,mBAAOC,CAAaC,EAAehL,GACxC,GAAIgL,EAAMtP,SAAWsE,EAAEtE,OACrB,MAAM,IAAIQ,MAAM,kBAElB,MAAO,IAAM8O,EAAMtQ,IAAI,CAACsC,EAAGpC,IAAMoC,EAAE+B,cAAciB,EAAEpF,KAAKgM,KAAK,MAAQ,GACvE,CAEA9L,WAAAA,CACSmQ,EACAC,GAC0B,IAA1BC,EAAA9D,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAAwB,GAE/BzE,QAJO,KAAAqI,SAAAA,EACA,KAAAC,SAAAA,EACA,KAAAC,YAAAA,CAGT,CAEOpL,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAEtB,UAAUtD,KAAM6E,EAC3B,CACOC,SAAAA,CAAUvF,GACf,GAAIiK,MAAMC,QAAQlK,IAAmB,IAAbA,EAAEe,QAAgBf,EAAE,IAAMA,EAAE,GAAG+P,cAAgC,kBAAT/P,EAAE,GAC9E,OAAO,EACT,MAAM,IAAIuB,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAWiL,GAA+C,IAA7CC,EAAWC,GAAkCF,EAC/D,MAAM5P,EAAM6P,EAAUV,eAChBtO,GAAMC,EAAAA,EAAAA,IAAUd,EAAImG,YACpB4J,GAAWhP,EAAAA,EAAAA,IAAO,IAAI0E,WAAW,CAAC,IAAK5E,EAAKb,GAE5CgQ,GAAS,IAAIzR,aAAcC,OAAOsR,GAClCG,GAAYnP,EAAAA,EAAAA,IAAUkP,EAAO7J,YACnC,OAAOpF,EAAAA,EAAAA,IAAO,IAAI0E,WAAW,CAAC,IAAKsK,EAAUE,EAAWD,EAC1D,CAEOrM,mBAAAA,CAAoBgJ,GACzB/M,KAAK6P,SAAS7C,QAAQsD,GAAOA,EAAIzM,eAAekJ,IAChD/M,KAAK8P,SAAS9C,QAAQsD,GAAOA,EAAIzM,eAAekJ,IAEhD,MAAMjC,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAWuR,MAC/BC,GAAStP,EAAAA,EAAAA,IAAUlB,KAAK6P,SAASvP,QACjCmQ,GAAOtP,EAAAA,EAAAA,OAAUnB,KAAK6P,SAASvQ,IAAIgR,GAAOA,EAAIhM,WAAWyI,KACzD2D,GAASxP,EAAAA,EAAAA,IAAUlB,KAAK8P,SAASxP,QACjCiL,GAAOpK,EAAAA,EAAAA,OAAUnB,KAAK8P,SAASxQ,IAAIgR,GAAOA,EAAIhM,WAAWyI,KACzD4D,GAASzP,EAAAA,EAAAA,IAAUlB,KAAK+P,YAAYzP,QACpCsQ,GAAOzP,EAAAA,EAAAA,OAAUnB,KAAK+P,YAAYzQ,IAAI8M,GAAKpM,KAAK6Q,iBAAiBzE,KAEvEW,EAAE7M,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQ0F,EAAQC,EAAMC,EAAQnF,EAAMoF,EAAQC,GACjE,CAEO3L,WAAAA,CAAYE,EAASvD,GAC1B,MAAMkP,EAAKlP,aAAawC,EAAYxC,EAAEyC,WAAazC,EAAKA,EACxD,IAAKmP,GAAQD,EAAI9Q,MACf,MAAM,IAAIc,MACR,4CAA4Cd,KAAK0D,4BAA4BoN,EAAGpN,aAIpF,GAAU,KADAqC,EAAAA,EAAAA,IAAcZ,GAEtB,MAAM,IAAIrE,MAAM,oCAElB,MAAMqP,EAAWjB,EAAkB/J,GAE7B6L,EAAOzS,QAAOkI,EAAAA,EAAAA,IAAUtB,IACxB/E,GAAMsG,EAAAA,EAAAA,IAASvB,EAAG6L,GAIxB,MAAO,CAACb,EAHQ,IAAIxJ,YAAY,OAAQ,CAAEC,OAAO,IAC1BC,OAAOzG,GAGhC,CAEA,QAAIH,GAIF,MAAO,IAHMD,KAAK6P,SAASvQ,IAAIgR,GAAOA,EAAIrQ,MAAMuL,KAAK,cACxCxL,KAAK8P,SAASxQ,IAAIgR,GAAOA,EAAIrQ,MAAMuL,KAAK,SACvC,IAAMxL,KAAK+P,YAAYvE,KAAK,MAE5C,CAEO7H,aAAAA,CAAasN,GAAwC,IAAtChB,EAAWiB,GAA2BD,EAC1D,MAAO,SAAShB,EAAUR,aAAayB,GACzC,CAEOxN,OAAAA,GAIL,MAAO,IAHM1D,KAAK6P,SAASvQ,IAAIgR,GAAOA,EAAI5M,WAAW8H,KAAK,kBAC7CxL,KAAK8P,SAASxQ,IAAIgR,GAAOA,EAAI5M,WAAW8H,KAAK,SAC5C,IAAMxL,KAAK+P,YAAYvE,KAAK,MAE5C,CAEQqF,gBAAAA,CAAiBM,GACvB,GAAY,UAARA,EACF,OAAO,IAAItL,WAAW,CAAC,IAClB,GAAY,WAARsL,EACT,OAAO,IAAItL,WAAW,CAAC,IAClB,GAAY,oBAARsL,EACT,OAAO,IAAItL,WAAW,CAAC,IAEvB,MAAM,IAAI/E,MAAM,8BAEpB,EAGI,MAAOsQ,UAAqBjN,EAChC,YAAI9C,GACF,OAAOmC,EAAY4N,YACrB,CAEA,OAAQ5M,OAAOC,aAAaC,GAC1B,OAAOA,EAASrD,WAAamC,EAAY4N,YAC3C,CAGA1R,WAAAA,CAAYwD,GACVsE,QACAxH,KAAK+C,QAAUuC,OAAO4G,QAAQhJ,GAAQiJ,KAAK,CAACC,EAAGjH,IACzCiH,EAAE,GAAKjH,EAAE,IACH,EAENiH,EAAE,GAAKjH,EAAE,GACJ,EAEF,EAEX,CACOR,MAAAA,CAAaC,EAAkBC,GACpC,OAAOD,EAAErB,aAAavD,KAAM6E,EAC9B,CACOC,SAAAA,CAAUvF,GACf,GAAIA,GAAKA,EAAE+P,aAAc,OAAO,EAChC,MAAM,IAAIxO,MAAM,WAAWd,KAAK0D,uBAAuBE,EAAiBrE,KAC1E,CAEOwF,WAAAA,CAAYxF,GACjB,MAAMa,EAAMb,EAAEgQ,eACRtO,GAAMC,EAAAA,EAAAA,IAAUd,EAAIE,QAC1B,OAAOa,EAAAA,EAAAA,IAAO,IAAI0E,WAAW,CAAC,IAAK5E,EAAKb,EAC1C,CAEO2D,mBAAAA,CAAoBgJ,GACzB/M,KAAK+C,QAAQiK,QAAQqE,IAAA,IAAEnE,EAAGoE,GAAKD,EAAA,OAAKC,EAAKzN,eAAekJ,KACxD,MAAMjC,GAASxJ,EAAAA,EAAAA,GAAWtC,EAAWuS,SAC/BtQ,GAAMC,EAAAA,EAAAA,IAAUlB,KAAK+C,QAAQzC,QAC7BkR,EAAQxR,KAAK+C,QAAQzD,IAAImS,IAAkB,IAAhBtT,EAAOmT,GAAKG,EAC3C,MAAMC,GAAW,IAAI/S,aAAcC,OAAOT,GACpCwT,GAAWzQ,EAAAA,EAAAA,IAAUwQ,EAASpR,QACpC,OAAOa,EAAAA,EAAAA,IAAOwQ,EAAUD,EAAUJ,EAAKhN,WAAWyI,MAGpDA,EAAE7M,IAAIF,MAAMmB,EAAAA,EAAAA,IAAO2J,EAAQ7J,KAAQuQ,GACrC,CAEOvM,WAAAA,CAAYE,EAASvD,GAC1B,MAAMkP,EAAKlP,aAAawC,EAAYxC,EAAEyC,WAAazC,EAAKA,EACxD,IAAKmP,GAAQD,EAAI9Q,MACf,MAAM,IAAIc,MACR,2CAA2Cd,KAAK0D,4BAA4BoN,EAAGpN,aAGnF,OAAOwL,EAAkB/J,EAC3B,CACA,QAAIlF,GAEF,MAAO,YADQD,KAAK+C,QAAQzD,IAAIsS,IAAA,IAAErF,EAAK/G,GAAMoM,EAAA,OAAKrF,EAAM,IAAM/G,EAAMvF,OAC1CuL,KAAK,QACjC,CAEO7H,aAAAA,CAAcpE,GACnB,MAAO,YAAYA,EAAEkQ,WACvB,CAEO5B,cAAAA,GACL,MAAM3K,EAA+B,CAAC,EACtC,IAAK,MAAOjD,EAAMkD,KAAOnD,KAAK+C,QAC5BG,EAAOjD,GAAQkD,EAEjB,OAAOD,CACT,EAQF,SAASU,EAAiBrE,GACxB,MAAM2R,EAAMW,KAAKC,UAAUvS,EAAG,CAACwS,EAAMvM,IAClB,kBAAVA,EAAqB,UAAUA,KAAWA,GAGnD,OAAO0L,GAAOA,EAAI5Q,OAlzDS,IAmzDvB4Q,EAAIc,UAAU,EAAGC,KAA4B,MAC7Cf,CACN,CAQM,SAAUtS,EAAOiR,EAA4BY,GACjD,GAAIA,EAAKnQ,OAASuP,EAASvP,OACzB,MAAMQ,MAAM,qCAGd,MAAMgD,EAAY,IAAIrE,EACtBoQ,EAAS7C,QAAQpL,GAAKA,EAAEiC,eAAeC,IAEvC,MAAMoO,GAAQ,IAAIvT,aAAcC,OAAOK,GACjCkT,EAAQrO,EAAUlF,SAClBqC,GAAMC,EAAAA,EAAAA,IAAUuP,EAAKnQ,QACrB8R,GAAOjR,EAAAA,EAAAA,OAAU0O,EAASvQ,IAAIsC,GAAKA,EAAE0C,WAAWR,KAChDuO,GAAOlR,EAAAA,EAAAA,OACRjC,EAAQ2Q,EAAUY,EAAM,CAAC7O,EAAGrC,KAC7B,IACEqC,EAAEkD,UAAUvF,EACd,CAAE,MAAOoK,GAEP,MADY,IAAI7I,MAAM6I,EAAEC,QAAU,OAEpC,CAEA,OAAOhI,EAAEmD,YAAYxF,MAIzB,OAAO4B,EAAAA,EAAAA,IAAO+Q,EAAOC,EAAOlR,EAAKmR,EAAMC,EACzC,CAQM,SAAUxL,EAAOiJ,EAAkB7H,GACvC,MAAM9C,EAAI,IAAIwF,EAAAA,GAAK1C,GAEnB,GAAIA,EAAM1B,WAAatH,EAAYqB,OACjC,MAAM,IAAIQ,MAAM,4CAElB,MAAMwR,GAAc5L,EAAAA,EAAAA,IAASvB,EAAGlG,EAAYqB,QACtC4R,GAAQ,IAAIvL,aAAcE,OAAOyL,GACvC,GAAIJ,IAAUjT,EACZ,MAAM,IAAI6B,MAAM,uBAAyB+Q,KAAKC,UAAUI,IA+F1D,MAAOK,EAAUC,GA5FjB,SAAuBC,GACrB,MAAM3O,EAAsC,GACtC7C,EAAM1C,QAAOkI,EAAAA,EAAAA,IAAUgM,IAE7B,IAAK,IAAIjT,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAM2D,EAAK5E,QAAO0I,EAAAA,EAAAA,IAAWwL,IAC7B,OAAQtP,GACN,KAAKnE,EAAW0M,IAChB,KAAK1M,EAAW+L,OAAQ,CACtB,MAAMnJ,EAAIrD,QAAO0I,EAAAA,EAAAA,IAAWwL,IAC5B3O,EAAUtD,KAAK,CAAC2C,EAAIvB,IACpB,KACF,CACA,KAAK5C,EAAWmO,OAChB,KAAKnO,EAAWuP,QAAS,CACvB,MAAMrL,EAAS,GACf,IACIwP,EADAC,EAAepU,QAAOkI,EAAAA,EAAAA,IAAUgM,IAEpC,KAAOE,KAAgB,CACrB,MAAMnF,EAAOjP,QAAOkI,EAAAA,EAAAA,IAAUgM,IAC9B,GAAIjF,GAAQ5E,KAAKgK,IAAI,EAAG,IACtB,MAAM,IAAI9R,MAAM,gCAElB,GAAwB,kBAAb4R,GAAyBA,GAAYlF,EAC9C,MAAM,IAAI1M,MAAM,oCAElB4R,EAAWlF,EACX,MAAM5L,EAAIrD,QAAO0I,EAAAA,EAAAA,IAAWwL,IAC5BvP,EAAO1C,KAAK,CAACgN,EAAM5L,GACrB,CACAkC,EAAUtD,KAAK,CAAC2C,EAAID,IACpB,KACF,CACA,KAAKlE,EAAWuR,KAAM,CACpB,MAAME,EAAO,GACb,IAAIoC,EAAYtU,QAAOkI,EAAAA,EAAAA,IAAUgM,IACjC,KAAOI,KACLpC,EAAKjQ,KAAKjC,QAAO0I,EAAAA,EAAAA,IAAWwL,KAE9B,MAAMK,EAAe,GACrB,IAAIC,EAAqBxU,QAAOkI,EAAAA,EAAAA,IAAUgM,IAC1C,KAAOM,KACLD,EAAatS,KAAKjC,QAAO0I,EAAAA,EAAAA,IAAWwL,KAEtC,MAAM1C,EAAc,GACpB,IAAIiD,EAAmBzU,QAAOkI,EAAAA,EAAAA,IAAUgM,IACxC,KAAOO,KAAoB,CAEzB,OADmBzU,QAAOkI,EAAAA,EAAAA,IAAUgM,KAElC,KAAK,EACH1C,EAAYvP,KAAK,SACjB,MAEF,KAAK,EACHuP,EAAYvP,KAAK,UACjB,MAEF,KAAK,EACHuP,EAAYvP,KAAK,mBACjB,MAEF,QACE,MAAM,IAAIM,MAAM,sBAEtB,CACAgD,EAAUtD,KAAK,CAAC2C,EAAI,CAACsN,EAAMqC,EAAc/C,KACzC,KACF,CACA,KAAK/Q,EAAWuS,QAAS,CACvB,IAAI0B,EAAa1U,QAAOkI,EAAAA,EAAAA,IAAUgM,IAClC,MAAMS,EAAU,GAChB,KAAOD,KAAc,CACnB,MAAME,EAAa5U,QAAOkI,EAAAA,EAAAA,IAAUgM,IAC9BW,GAAW,IAAIzM,aAAcE,QAAOH,EAAAA,EAAAA,IAAS+L,EAAMU,IACnDE,GAAWpM,EAAAA,EAAAA,IAAWwL,GAC5BS,EAAQ1S,KAAK,CAAC4S,EAAUC,GAC1B,CACAvP,EAAUtD,KAAK,CAAC2C,EAAI+P,IACpB,KACF,CACA,QACE,MAAM,IAAIpS,MAAM,oBAAsBqC,GAE5C,CAEA,MAAMmQ,EAAoB,GACpBhT,EAAS/B,QAAOkI,EAAAA,EAAAA,IAAUgM,IAChC,IAAK,IAAIjT,EAAI,EAAGA,EAAIc,EAAQd,IAC1B8T,EAAQ9S,KAAKjC,QAAO0I,EAAAA,EAAAA,IAAWwL,KAEjC,MAAO,CAAC3O,EAAWwP,EACrB,CAC6BC,CAAcpO,GAC3C,GAAIqN,EAASlS,OAASwP,EAASxP,OAC7B,MAAM,IAAIQ,MAAM,iCAGlB,MAAMqR,EAAoBI,EAASjT,IAAI4N,GAAKsG,MAC5C,SAASnP,EAAQzC,GACf,GAAIA,GAAK,GACP,MAAM,IAAId,MAAM,8BAElB,GAAIc,EAAI,EACN,OAAQA,GACN,KAAM,EACJ,OAAOqE,EACT,KAAM,EACJ,OAAOH,EACT,KAAM,EACJ,OAAOuB,EACT,KAAM,EACJ,OAAOL,EACT,KAAM,EACJ,OAAOyM,GACT,KAAM,EACJ,OAAOC,GACT,KAAM,EACJ,OAAOC,GACT,KAAM,EACJ,OAAOC,GACT,KAAM,EACJ,OAAOC,GACT,KAAM,GACJ,OAAOC,GACT,KAAM,GACJ,OAAOC,GACT,KAAM,GACJ,OAAOC,GACT,KAAM,GACJ,OAAOjM,EACT,KAAM,GACJ,OAAOC,EACT,KAAM,GACJ,OAAOxB,EACT,KAAM,GACJ,OAAOH,EACT,KAAM,GACJ,OAAOrB,EACT,KAAM,GACJ,OAAOwK,GACT,QACE,MAAM,IAAI1O,MAAM,oBAAsBc,GAG5C,GAAIA,GAAK2Q,EAASjS,OAChB,MAAM,IAAIQ,MAAM,2BAElB,OAAOqR,EAAMvQ,EACf,CACA,SAASqS,EAAUC,GACjB,OAAQA,EAAM,IACZ,KAAKlV,EAAW+L,OAEd,OAAOoJ,GADI9P,EAAQ6P,EAAM,KAG3B,KAAKlV,EAAW0M,IAEd,OAAOA,GADIrH,EAAQ6P,EAAM,KAG3B,KAAKlV,EAAWmO,OAAQ,CACtB,MAAMjK,EAA+B,CAAC,EACtC,IAAK,MAAOsK,EAAMrK,KAAO+Q,EAAM,GAAI,CAEjChR,EADa,IAAIsK,MACFnJ,EAAQlB,EACzB,CACA,MAAMkK,EAASF,GAAOjK,GAChBiL,EAAQd,EAAOhB,aACrB,OAAI7C,MAAMC,QAAQ0E,GACTiG,MAASjG,GAETd,CAEX,CACA,KAAKrO,EAAWuP,QAAS,CACvB,MAAMrL,EAA+B,CAAC,EACtC,IAAK,MAAOsK,EAAMrK,KAAO+Q,EAAM,GAAI,CAEjChR,EADa,IAAIsK,MACFnJ,EAAQlB,EACzB,CACA,OAAOoL,GAAQrL,EACjB,CACA,KAAKlE,EAAWuR,KAAM,CACpB,MAAOE,EAAMqC,EAAc/C,GAAemE,EAAM,GAChD,OAAO3D,GACLE,EAAKnR,IAAKsC,GAAcyC,EAAQzC,IAChCkR,EAAaxT,IAAKsC,GAAcyC,EAAQzC,IACxCmO,EAEJ,CACA,KAAK/Q,EAAWuS,QAAS,CACvB,MAAM8C,EAAiC,CAAC,EAClCnB,EAAUgB,EAAM,GACtB,IAAK,MAAOjU,EAAMqU,KAAYpB,EAAS,CACrC,IAAI/S,EAAyBkE,EAAQiQ,GAMrC,GAJInU,aAAgBiE,IAElBjE,EAAOA,EAAKkE,aAERlE,aAAgBuP,GACpB,MAAM,IAAI5O,MAAM,mEAElBuT,EAAIpU,GAAQE,CACd,CACA,OAAOoR,GAAQ8C,EACjB,CACA,QACE,MAAM,IAAIvT,MAAM,oBAAsBoT,EAAM,IAElD,CAEA3B,EAASvF,QAAQ,CAACkH,EAAO1U,KAEvB,GAAI0U,EAAM,KAAOlV,EAAWuR,KAAM,CAChC,MAAM3O,EAAIqS,EAAUC,GACpB/B,EAAM3S,GAAGyP,KAAKrN,EAChB,IAEF2Q,EAASvF,QAAQ,CAACkH,EAAO1U,KACvB,GAAI0U,EAAM,KAAOlV,EAAWuR,KAAM,CAChC,MAAM3O,EAAIqS,EAAUC,GACpB/B,EAAM3S,GAAGyP,KAAKrN,EAChB,IAGF2S,KACA,MAAM3E,EAAQ4C,EAASlT,IAAIsC,GAAKyC,EAAQzC,IACxC,IACE,MAAM4S,EAAS1E,EAASxQ,IAAI,CAACsC,EAAGpC,IACvBoC,EAAEqD,YAAYE,EAAGyK,EAAMpQ,KAIhC,IAAK,IAAIiV,EAAM3E,EAASxP,OAAQmU,EAAM7E,EAAMtP,OAAQmU,IAClD7E,EAAM6E,GAAKxP,YAAYE,EAAGyK,EAAM6E,IAGlC,GAAItP,EAAEoB,WAAa,EACjB,MAAM,IAAIzF,MAAM,2BAGlB,OAAO0T,CACT,CAAE,QACAD,IACF,CACF,CA4CO,MAAMvP,EAAQ,IAAIT,EACZ8B,EAAW,IAAIF,EAIfuO,EAAU,IAAIxP,EACdY,EAAO,IAAIF,EACXK,EAAO,IAAID,EACXQ,EAAO,IAAIF,EACXU,EAAM,IAAIF,EACVO,EAAM,IAAIF,EAEVY,EAAU,IAAIT,EAAW,IACzBU,EAAU,IAAIV,EAAW,IAEzBuM,GAAO,IAAIxL,EAAc,GACzByL,GAAQ,IAAIzL,EAAc,IAC1B0L,GAAQ,IAAI1L,EAAc,IAC1B2L,GAAQ,IAAI3L,EAAc,IAE1BoL,GAAO,IAAI1K,EAAc,GACzB2K,GAAQ,IAAI3K,EAAc,IAC1B4K,GAAQ,IAAI5K,EAAc,IAC1B6K,GAAQ,IAAI7K,EAAc,IAE1ByG,GAAY,IAAIH,EAOvB,SAAU+E,KAAkC,QAAAO,EAAA1I,UAAA3L,OAARsP,EAAQ,IAAApG,MAAAmL,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAARhF,EAAQgF,GAAA3I,UAAA2I,GAChD,OAAO,IAAI5I,EAAW4D,EACxB,CAMM,SAAUuE,GAAOvS,GACrB,OAAO,IAAIsH,EAAStH,EACtB,CAMM,SAAU8J,GAAO9J,GACrB,OAAO,IAAI6J,EAAS7J,EACtB,CAMM,SAAUuL,GAAOvL,GACrB,OAAO,IAAImK,EAAYnK,EACzB,CAOM,SAAU2M,GAAQrL,GACtB,OAAO,IAAIkL,EAAalL,EAC1B,CAKM,SAAUsQ,KACd,OAAO,IAAIpP,CACb,CASM,SAAUmM,GAAKE,EAAcoE,GACjC,OAAO,IAAInF,EAAUe,EAAMoE,EADmB5I,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAAwB,GAExE,CAOM,SAAUsF,GAAQ3P,GACtB,OAAO,IAAIwP,EAAaxP,EAC1B,CAKA,MAAMkT,GAGJpV,WAAAA,GAAiC,IAArBqV,EAAS9I,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAAG,IAAIpM,IAC1BG,KAAKgV,KAAOD,CACd,CAEAE,IAAAA,GACE,MAAMA,EAAO,IAAIpV,IACjB,IAAK,MAAO0M,EAAK/G,KAAUxF,KAAKgV,KAAK9I,UAAW,CAC9C,MAAMgJ,EAAU,IAAIrV,IAAI2F,GACxByP,EAAK1U,IAAIgM,EAAK2I,EAChB,CACA,OAAO,IAAIJ,GAAUG,EACvB,CAIAE,KAAAA,CAAMC,EAAUC,GACd,OAAOrV,KAAKgV,KAAKrU,IAAIyU,EAAGnV,OAAOU,IAAI0U,EAAGpV,KACxC,CAEAqV,WAAAA,CAAYF,EAAUC,GACpBrV,KAAKuV,SAASH,EAAGnV,KAAMoV,EAAGpV,MAAM,EAClC,CAEAC,GAAAA,CAAIkV,EAAUC,GACZrV,KAAKuV,SAASH,EAAGnV,KAAMoV,EAAGpV,MAAM,EAClC,CAEAyD,OAAAA,GACE,IAAIyH,EAAS,GACb,IAAK,MAAOiK,EAAIxQ,KAAM5E,KAAKgV,KACzB,IAAK,MAAOK,EAAIF,KAAUvQ,EAAG,CAE3BuG,GAAU,GAAGiK,KADCD,EAAQ,KAAO,SACDE,KAC9B,CAEF,OAAOlK,CACT,CAEQoK,QAAAA,CAASH,EAAYC,EAAYG,GACvC,MAAMC,EAAQzV,KAAKgV,KAAKrU,IAAIyU,GAC5B,QAAavU,GAAT4U,EAAoB,CACtB,MAAMC,EAAS,IAAI7V,IACnB6V,EAAOnV,IAAI8U,EAAIG,GACfxV,KAAKgV,KAAKzU,IAAI6U,EAAIM,EACpB,MACED,EAAMlV,IAAI8U,EAAIG,EAElB,EAIF,IAAIG,GAA0B,IAAIb,GAG5B,SAAUP,KACdoB,GAAe,IAAIb,EACrB,CAcA,SAASc,GAAchU,GACrB,OAAOA,aAAa6J,GAAY7J,aAAaoE,GAAapE,aAAauE,CACzE,CAOM,SAAU4K,GAAQqE,EAAUC,GAChC,MACMG,EAAYK,GADAF,GAAaV,OACOG,EAAIC,GAM1C,OALIG,EACFG,GAAazV,IAAIkV,EAAIC,GAErBM,GAAaL,YAAYF,EAAIC,GAExBG,CACT,CAEA,SAASK,GAASd,EAAsBK,EAAUC,GAChD,GAAID,EAAGnV,OAASoV,EAAGpV,KAAM,OAAO,EAChC,MAAMkV,EAAQJ,EAAUI,MAAMC,EAAIC,GAClC,QAAcxU,IAAVsU,EAAqB,OAAOA,EAGhC,GAFAJ,EAAU7U,IAAIkV,EAAIC,GAEdA,aAAclP,EAAe,OAAO,EACxC,GAAIiP,aAAc7Q,EAAY,OAAO,EACrC,GAAI6Q,aAAcjO,GAAYkO,aAAcvO,EAAU,OAAO,EAC7D,GAAIsO,aAAclM,GAAYmM,aAAcnM,EAC1C,OAAO2M,GAASd,EAAWK,EAAGjM,MAAOkM,EAAGlM,OAC1C,GAAIkM,aAAc5J,EAAU,OAAO,EACnC,GAAI2J,aAAcrJ,GAAesJ,aAActJ,EAAa,CAC1D,MAAM+J,EAAWV,EAAGvH,eACpB,IAAK,MAAO1P,EAAO4X,KAAQV,EAAGtS,QAAS,CACrC,MAAMiT,EAAMF,EAAS5X,EAAaC,IAClC,GAAK6X,GAGH,IAAKH,GAASd,EAAWiB,EAAKD,GAAM,OAAO,OAF3C,IAAKH,GAAcG,GAAM,OAAO,CAIpC,CACA,OAAO,CACT,CAEA,GAAIX,aAAc1F,GAAa2F,aAAc3F,EAAW,CACtD,IA1DJ,SAA+B0F,EAAeC,GAC5C,MAAMY,EAAgB,IAAIC,IAAId,EAAGrF,aAC3BoG,EAAgB,IAAID,IAAIb,EAAGtF,aACjC,GAAIkG,EAAcG,OAASD,EAAcC,KACvC,OAAO,EAET,IAAK,MAAMhK,KAAK6J,EACd,IAAKE,EAAcrW,IAAIsM,GAAI,OAAO,EAEpC,OAAO,CACT,CAgDSiK,CAAsBjB,EAAIC,GAAK,OAAO,EAC3C,IAAK,IAAI7V,EAAI,EAAGA,EAAI4V,EAAGvF,SAASvP,OAAQd,IAAK,CAC3C,MAAM8W,EAASlB,EAAGvF,SAASrQ,GAC3B,GAAIA,EAAI6V,EAAGxF,SAASvP,QAClB,IAAKuV,GAASd,EAAWM,EAAGxF,SAASrQ,GAAI8W,GAAS,OAAO,OAEzD,IAAKV,GAAcU,GAAS,OAAO,CAEvC,CACA,IAAK,IAAI9W,EAAI,EAAGA,EAAI6V,EAAGvF,SAASxP,OAAQd,IAAK,CAC3C,MAAM+W,EAASlB,EAAGvF,SAAStQ,GAC3B,GAAIA,EAAI4V,EAAGtF,SAASxP,QAClB,IAAKuV,GAASd,EAAWK,EAAGtF,SAAStQ,GAAI+W,GAAS,OAAO,OAEzD,IAAKX,GAAcW,GAAS,OAAO,CAEvC,CACA,OAAO,CACT,CAEA,GAAInB,aAAchH,GAAgBiH,aAAcjH,EAAc,CAC5D,MAAMoI,EAAWnB,EAAGxG,qBACpB,IAAK,MAAO1Q,EAAO6X,KAAQZ,EAAGrS,QAAS,CACrC,MAAMgT,EAAMS,EAAStY,EAAaC,IAClC,IAAK4X,EAAK,OAAO,EACjB,IAAKF,GAASd,EAAWiB,EAAKD,GAAM,OAAO,CAC7C,CACA,OAAO,CACT,CAEA,GAAIX,aAAchE,GAAgBiE,aAAcjE,EAAc,CAC5D,MAAM0E,EAAWV,EAAGvH,iBACpB,IAAK,MAAO5N,EAAM8V,KAAQV,EAAGtS,QAAS,CACpC,MAAMiT,EAAMF,EAAS7V,GACrB,IAAK+V,EAAK,OAAO,EACjB,IAAKH,GAASd,EAAWiB,EAAKD,GAAM,OAAO,CAC7C,CACA,OAAO,CACT,CAEA,OAAIX,aAAchR,EACTyR,GAASd,EAAWK,EAAG/Q,UAAYgR,GAExCA,aAAcjR,GACTyR,GAASd,EAAWK,EAAIC,EAAGhR,UAGtC,C,cCj7EM,SAAUoS,KACd,OA+GI,WAA6C,QAAA9B,EAAA1I,UAAA3L,OAA1BoW,EAA0B,IAAAlN,MAAAmL,GAAA5C,EAAA,EAAAA,EAAA4C,EAAA5C,IAA1B2E,EAA0B3E,GAAA9F,UAAA8F,GACjD,OAAO4E,MACLC,EACAC,EACAC,KAEA,IAAK,MAAM1K,KAAKsK,QACRtK,EAAEwK,EAAYC,EAAWC,GAGrC,CAzHSC,EAsBwBC,EAhB3B,WACJ,IAAIC,GAAQ,EACZ,OAAON,WACDM,IACFA,GAAQ,GACD,EAIb,CAfgCC,GAsBgCC,EAtBxB,IAuB/BR,MACLC,EACAC,EACAC,KAEA,SAAUE,EAAUJ,EAAYC,EAAWC,GACzC,OAAO,IAAIM,QAAQC,GAAWC,WAAWD,EAASF,MAiElD,SAAkBI,EAAgCC,GACtD,IAAIC,EAAoBF,EAExB,MAAO,IACL,IAAIH,QAAQC,GACVC,WAAW,KACTG,GAAqBD,EACrBH,KACCI,GAET,CAxG+CC,CAAQ,IAAM,KAqEvD,SAAkBP,GACtB,MAAMQ,EAAMC,KAAKC,MAAQV,EACzB,OAAOR,MACLmB,EACAjB,EACAC,KAEA,GAAIc,KAAKC,MAAQF,EACf,MAAMI,EAAAA,GAAcC,SAClB,IAAIC,EAAAA,GACF,2BAA2Bd,SAC3BN,EACAC,IAKV,CAtFmEoB,CAPtC,MA6BvB,IAA2BlB,EAA+BG,CArBhE,C,iCC8CO,MAAMgB,GAA0C,CACrDC,SAAU3B,KACV4B,yBAAyB,GAQ3B,SAASC,GACP9S,EACA+S,GAEA,OAAOjT,OAAOkT,UAAU9L,eAAe+L,KAAKjT,EAAO+S,EACrD,CAEA,SAASG,GACPlT,EACA+S,GAEA,OAAiB,OAAV/S,GAAmC,kBAAVA,GAAsB8S,GAAY9S,EAAO+S,EAC3E,CAaA,SAASI,GACPnT,GAEA,OACEkT,GAAqBlT,EAAO,SAC5BkT,GAAqBlT,EAAMoT,KAAM,YAChCpT,EAAMoT,KAAKC,QAA8CC,eACxDC,GAAAA,GAAgBC,WAClBN,GAAqBlT,EAAMoT,KAAKC,QAAS,mBACI,kBAAtCrT,EAAMoT,KAAKC,QAAQI,gBACY,OAAtCzT,EAAMoT,KAAKC,QAAQI,gBArBvB,SACEzT,EACA+S,GAEA,OAAOD,GAAY9S,EAAO+S,IAAwC,oBAApB/S,EAAM+S,EACtD,CAiBIW,CAAY1T,EAAMoT,KAAKC,QAAQI,eAAgB,SAEnD,CAUOtC,eAAewC,GACpBC,EACAxC,EACAC,GAC4B,IAA5BwC,EAAApN,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAA0B,CAAC,EAK3B,MAAMqN,EAAO,EAACC,EAAAA,GAAAA,IAAY,kBAAmB1C,GAE7C,IAAI2C,EACAC,EAeJ,GAdgCJ,EAAQhB,0BAA2B,GAGjEoB,QAqFG9C,eAAgC0C,GAKrC,MAAM,MAAEK,EAAK,MAAEN,EAAK,eAAEO,GAAmBN,EACzC,GAAIM,EAAeC,SAAWjB,GAAmCgB,EAAeC,SAC9E,OAAOD,EAAeC,QAExB,MAAMA,QAAgBR,EAAMS,yBAC1B,CACEH,cAEF7Y,IAEF,IAAK8X,GAAmCiB,GACtC,MAAME,EAAAA,GAAW9B,SAAS,IAAI+B,EAAAA,GAAiCH,IAEjE,OAAOA,CACT,CAxG2BI,CAAiB,CACtCN,MAAO,CAACJ,GACRF,QACAO,eAAgBN,IAElBG,QAAcJ,EAAMa,UAAUrD,EAAY,CAAE8C,MAAO,CAACJ,SAASzY,EAAW4Y,IAGxED,QAAcJ,EAAMa,UAAUrD,EAAY,CAAE8C,MAAO,CAACJ,KAGjC,MAAjBF,EAAMc,QACR,MAAMC,EAAAA,GAAcnC,SAAS,IAAIoC,EAAAA,IAEnC,MAAMC,QAAaC,GAAAA,GAAYC,OAAO,CACpCC,YAAahB,EAAMgB,YACnBN,QAASd,EAAMc,QACftD,WAAYA,EACZ6D,UAAWpB,EAAQoB,YAGfC,GAAWC,EAAAA,GAAAA,IAAqBN,EAAKO,YAAY,IAAItB,GAAMC,EAAAA,GAAAA,IAAY,aAC7E,IAAIzC,EAQJ,OALEA,EAFsB,qBAAb4D,EAEAG,GAAAA,GAA4BnG,SAE5B,IAAI/N,aAAcE,OAAO6T,GAG5B5D,GACN,KAAK+D,GAAAA,GAA4BC,QAC/B,MAAO,CACLC,OAAOJ,EAAAA,GAAAA,IAAqBN,EAAKO,YAAY,IAAItB,EAAM,WACvDkB,YAAaH,GAIjB,KAAKQ,GAAAA,GAA4BG,SACjC,KAAKH,GAAAA,GAA4BnG,QACjC,KAAKmG,GAAAA,GAA4BI,WAAY,CAE3C,MAAM7C,EAAWiB,EAAQjB,UAAY3B,KAErC,aADM2B,EAASxB,EAAYC,EAAWC,GAC/BqC,GAAgBC,EAAOxC,EAAYC,EAAW,IAChDwC,EACHO,QAASH,GAEb,CAEA,KAAKoB,GAAAA,GAA4BK,SAAU,CACzC,MAAMC,EAAa,IAAItV,YACrB8U,EAAAA,GAAAA,IAAqBN,EAAKO,YAAY,IAAItB,EAAM,kBAChD,GACI8B,GAAgB,IAAIzU,aAAcE,QACtC8T,EAAAA,GAAAA,IAAqBN,EAAKO,YAAY,IAAItB,EAAM,qBAE5C+B,GAAeV,EAAAA,GAAAA,IAAqBN,EAAKO,YAAY,IAAItB,EAAM,gBAC/DgC,EAAYD,GAAe,IAAI1U,aAAcE,OAAOwU,QAAgBxa,EAC1E,MAAM0a,EAAAA,GAAYvD,SAChB,IAAIwD,EAAAA,GAAyB3E,EAAWsE,EAAYC,EAAeE,GAEvE,CAEA,KAAKT,GAAAA,GAA4BY,KAG/B,MAAMC,EAAAA,GAAa1D,SAAS,IAAI2D,EAAAA,GAAkC9E,IAEtE,MAAM+E,EAAAA,EACR,CChCA,MAAMC,GAAiBrX,OAAOsX,IAAI,qBAW5B,MAAOC,GAMJ,cAAOC,CAAQC,GACpB,OAAOA,EAAMJ,IAAgBK,OAAO9C,KACtC,CAMO,kBAAO+C,CAAYF,GACxB,OAAOA,EAAMJ,IAAgBO,OAC/B,CAEO,mBAAOC,CAAaJ,GACzB,OAAOzM,EAAAA,EAAU8M,KAAKL,EAAMJ,IAAgBK,OAAOtF,WACrD,CAEO,uBAAO2F,CACZC,EACAnD,GAEA,MAAM+C,EAAUI,EAAiB,CAAEC,IAAGA,IAoCtC,OAlCA,cAA4BV,GAG1Brc,WAAAA,CAAYwc,GACV,IAAKA,EAAOtF,WACV,MAAMkD,EAAAA,GAAW9B,SAAS,IAAI0E,EAAAA,GAA2BR,EAAOtF,aAElE,MAAMA,EACyB,kBAAtBsF,EAAOtF,WACVpH,EAAAA,EAAUmN,SAAST,EAAOtF,YAC1BsF,EAAOtF,WAEbpP,MAAM,CACJ0U,OAAQ,IACHU,MACAV,EACHtF,cAEFwF,YAGF,IAAK,MAAOlM,EAAYoB,KAAS8K,EAAQrZ,QACnCsW,GAASwD,aACXvL,EAAKvB,YAAYvP,KAAKsc,IAEpBzD,GAASmB,aACXlJ,EAAKvB,YAAYvP,KAAKuc,IAGxB/c,KAAKkQ,GAAc8M,GAAmBhd,KAAMkQ,EAAYoB,EAAM4K,EAAOzB,UAEzE,EAIJ,CAEO,kBAAOwC,CACZT,EACAU,GAEA,IAAKA,EAActG,WACjB,MAAMkD,EAAAA,GAAW9B,SAAS,IAAI0E,EAAAA,GAA2BQ,EAActG,aAEzE,OAAO,IAAK5W,KAAKuc,iBAAiBC,GAA3B,CACLU,EAEJ,CAQO,iCAAOC,CACZX,EACAU,GAEA,OAAO,IAAKld,KAAKuc,iBAAiBC,EAAkB,CAAEK,aAAa,IAA5D,CACLK,EAEJ,CAQO,qCAAOE,CACZZ,EACAU,GAIC,IAHDG,EAAApR,UAAA3L,OAAA,QAAAO,IAAAoL,UAAA,GAAAA,UAAA,GAA0C,CACxC4Q,aAAa,EACbrC,aAAa,GAGf,OAAO,IAAKxa,KAAKuc,iBAAiBC,EAAkBa,GAA7C,CACLH,EAEJ,CAIAxd,WAAAA,CAAsB4d,GACpBtd,KAAK6b,IAAkBvW,OAAOiY,OAAOD,EACvC,EAMF,SAASE,GAAkB5N,EAAmB6N,GAC5C,MAAM3K,EAAe2J,EAAW7M,EAAO6N,GACvC,OAAQ3K,EAAaxS,QACnB,KAAK,EACH,OACF,KAAK,EACH,OAAOwS,EAAa,GACtB,QACE,OAAOA,EAEb,CAEA,MAAM8J,GAA6C,CACjDjD,eAAgBxB,IAKL2E,GAAiC,eACjCC,GAAgC,cAE7C,SAASC,GACPf,EACA/L,EACAoB,EACAmJ,GAEA,IAAIiD,EAEFA,EADEpM,EAAKvB,YAAY4N,SAAS,UAAYrM,EAAKvB,YAAY4N,SAAS,mBACzDhH,eAAO0C,GAAoB,QAAA1E,EAAA1I,UAAA3L,OAARmQ,EAAI,IAAAjH,MAAAmL,EAAA,EAAAA,EAAA,KAAA5C,EAAA,EAAAA,EAAA4C,EAAA5C,IAAJtB,EAAIsB,EAAA,GAAA9F,UAAA8F,GAU9B,MAAMqH,GARNC,EAAU,IACLA,KACA4C,EAAMJ,IAAgBK,OAAO0B,iBAAiB1N,EAAYO,EAAM,IAC9DwL,EAAMJ,IAAgBK,UACtB7C,MAIeD,OAAS6C,EAAMJ,IAAgBK,OAAO9C,OAAS,IAAIyE,GAAAA,GACnEC,EAAMtO,EAAAA,EAAU8M,KAAKjD,EAAQzC,YAAcqF,EAAMJ,IAAgBK,OAAOtF,YACxEtG,EAAMmM,EAAWnL,EAAKzB,SAAUY,GAEhCtF,QAAeiO,EAAM2E,MAAMD,EAAK,CACpC5N,aACAI,MACA0N,oBAAqB3E,EAAQ2E,sBAEzBnB,EAAc,IACf1R,EAAO0R,YACVoB,eAAgB9S,EAAO8S,gBAGzB,OAAQ9S,EAAO2L,QACb,KAAKoH,EAAAA,GAAoBhD,SAAU,CACjC,MAAMiD,EAA6B,IAAIC,EAAAA,GACrCjT,EAAO0L,UACP1L,EAAOkT,YACPlT,EAAOmT,eACPnT,EAAOoT,WACPpT,EAAOqT,YAOT,MALAL,EAA2BM,YAAc,CACvC7H,WAAYkH,EACZ5N,aACA2M,eAEItB,EAAAA,GAAYvD,SAASmG,EAC7B,CAEA,KAAKD,EAAAA,GAAoBpD,QACvB,OAAOxJ,EAAKvB,YAAY4N,SAASb,IAC7B,CACED,cACA1R,OAAQqS,GAAkBlM,EAAKxB,SAAU3E,EAAO4P,MAAMzK,MAExDkN,GAAkBlM,EAAKxB,SAAU3E,EAAO4P,MAAMzK,KAExD,EAESqG,eAAO0C,GAAoB,QAAAqF,EAAAzS,UAAA3L,OAARmQ,EAAI,IAAAjH,MAAAkV,EAAA,EAAAA,EAAA,KAAA9J,EAAA,EAAAA,EAAA8J,EAAA9J,IAAJnE,EAAImE,EAAA,GAAA3I,UAAA2I,GAU9B,MAAMwE,GARNC,EAAU,IACLA,KACA4C,EAAMJ,IAAgBK,OAAOyC,gBAAgBzO,EAAYO,EAAM,IAC7DwL,EAAMJ,IAAgBK,UACtB7C,MAIeD,OAAS6C,EAAMJ,IAAgBK,OAAO9C,OAASyE,GAAAA,GAAUe,cAEzE,WAAEhI,EAAU,oBAAEoH,EAAmB,eAAErE,GAAmB,IACvDiD,MACAX,EAAMJ,IAAgBK,UACtB7C,GAECyE,EAAMtO,EAAAA,EAAU8M,KAAK1F,GACrBiI,OAA+Bhe,IAAxBmd,EAAoCxO,EAAAA,EAAU8M,KAAK0B,GAAuBF,EACjFxN,EAAMmM,EAAWnL,EAAKzB,SAAUY,IAEhC,UAAEoG,EAAS,SAAEiI,EAAQ,eAAEb,SAAyB7E,EAAMX,KAAKqF,EAAK,CACpE5N,aACAI,MACA0N,oBAAqBa,EACrBE,MAAO1F,EAAQ0F,QAEjB,IAAIhE,EACAP,EACJ,IAAIwE,EAAAA,EAAAA,IAAiBF,EAASlG,MAAO,CACnC,GAAqB,MAAjBQ,EAAMc,QACR,MAAMC,EAAAA,GAAcnC,SAAS,IAAIoC,EAAAA,IAEnC,MAAMC,EAAOyE,EAASlG,KAAK4B,YAC3BA,QAAoBF,GAAAA,GAAYC,OAAO,CACrCC,YAAaH,EACbH,QAASd,EAAMc,QACftD,WAAYpH,EAAAA,EAAU8M,KAAK1F,GAC3B6D,cAEF,MAAMnB,EAAO,EAACC,EAAAA,GAAAA,IAAY,kBAAmB1C,GAK7C,QAJe,IAAIlQ,aAAcE,QAC/B8T,EAAAA,GAAAA,IAAqBH,EAAYI,YAAY,IAAItB,EAAM,cAIvD,IAAK,UACHyB,GAAQJ,EAAAA,GAAAA,IAAqBH,EAAYI,YAAY,IAAItB,EAAM,WAC/D,MACF,IAAK,WAAY,CAEf,MAAM6B,EAAa,IAAItV,YACrB8U,EAAAA,GAAAA,IAAqBH,EAAYI,YAAY,IAAItB,EAAM,kBACvD,GACI8B,GAAgB,IAAIzU,aAAcE,QACtC8T,EAAAA,GAAAA,IAAqBH,EAAYI,YAAY,IAAItB,EAAM,qBAGnD2F,GAAiBtE,EAAAA,GAAAA,IACrBH,EAAYI,YAAY,IAAItB,EAAM,gBAE9BiF,EAAaU,GACf,IAAItY,aAAcE,OAAOoY,QACzBpe,EAEEqe,EAA2B,IAAI1D,EAAAA,GACnC3E,EACAsE,EACAC,EACAmD,GAOF,MALAW,EAAyBT,YAAc,CACrC7H,WAAYkH,EACZ5N,aACA2M,YAAaiC,GAETvD,EAAAA,GAAYvD,SAASkH,EAC7B,EAEJ,MAAO,IAAIC,EAAAA,EAAAA,IAAiBL,EAASlG,MAAO,CAE1C,MAAM,YAAEyF,EAAW,eAAEC,EAAc,WAAEC,GAAeO,EAASlG,KACvDsG,EAA2B,IAAI1D,EAAAA,GACnC3E,EACAwH,EACAC,EACAC,GAOF,MALAW,EAAyBT,YAAc,CACrC7H,WAAYkH,EACZ5N,aACA2M,YAAaiC,GAETvD,EAAAA,GAAYvD,SAASkH,EAC7B,CAGA,GAAwB,MAApBJ,EAAShI,OAAgB,CAC3B,MAAMsI,EAA8B,IAC/BzF,EACHc,aAGIqE,QAAiB3F,GAAgBC,EAAOyF,EAAMhI,EAAWuI,GAC/D5E,EAAcsE,EAAStE,YACvBO,EAAQ+D,EAAS/D,KACnB,CACA,MAAMsE,EAA2B/N,EAAKvB,YAAY4N,SAASb,IACrDwC,EAA2BhO,EAAKvB,YAAY4N,SAASZ,IAErDF,EAAc,IAAKiC,EAAUb,kBACnC,QAAcpd,IAAVka,EACF,OAAIsE,GAA4BC,EACvB,CACLzC,cACArC,cACArP,OAAQqS,GAAkBlM,EAAKxB,SAAUiL,IAElCuE,EACF,CACL9E,cACArP,OAAQqS,GAAkBlM,EAAKxB,SAAUiL,IAElCsE,EACF,CACLxC,cACA1R,OAAQqS,GAAkBlM,EAAKxB,SAAUiL,IAGtCyC,GAAkBlM,EAAKxB,SAAUiL,GACnC,GAA6B,IAAzBzJ,EAAKxB,SAASxP,OACvB,OAAO+e,EACH,CACExC,YAAaiC,EACb3T,YAAQtK,QAEVA,EAEJ,MAAM6a,EAAAA,GAAa1D,SACjB,IAAIuH,EAAAA,GACF,0CAA0CjO,EAAKxB,SAASxQ,IAAIsC,GAAKA,EAAE8B,WAAW8H,KAAK,UAI3F,EAGF,MAAMgU,EAAU,mBAAAC,EAAAxT,UAAA3L,OAAImQ,EAAe,IAAAjH,MAAAiW,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAfjP,EAAeiP,GAAAzT,UAAAyT,GAAA,OAAKhC,EAAO,CAAC,KAAMjN,EAAK,EAK3D,OAJA+O,EAAQG,YACLtG,GACD,mBAAAuG,EAAA3T,UAAA3L,OAAImQ,EAAe,IAAAjH,MAAAoW,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAfpP,EAAeoP,GAAA5T,UAAA4T,GAAA,OACjBnC,EAAOrE,KAAY5I,EAAK,EACrB+O,CACT,C","sources":["../node_modules/@dfinity/candid/src/utils/hash.ts","../node_modules/@dfinity/candid/src/idl.ts","../node_modules/@dfinity/agent/src/polling/strategy.ts","../node_modules/@dfinity/agent/src/polling/index.ts","../node_modules/@dfinity/agent/src/actor.ts"],"sourcesContent":["/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s: string): number {\n  const utf8encoder = new TextEncoder();\n  const array = utf8encoder.encode(s);\n\n  let h = 0;\n  for (const c of array) {\n    h = (h * 223 + c) % 2 ** 32;\n  }\n  return h;\n}\n\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nexport function idlLabelToId(label: string): number {\n  if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n    const num = +label.slice(1, -1);\n    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n      return num;\n    }\n  }\n  return idlHash(label);\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { type JsonValue } from './types.ts';\nimport { concat, PipeArrayBuffer as Pipe, uint8ToDataView } from './utils/buffer.ts';\nimport { idlLabelToId } from './utils/hash.ts';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128.ts';\nimport { iexp2 } from './utils/bigint-math.ts';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nenum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: Uint8Array[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: Uint8Array) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode(): Uint8Array {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string): Uint8Array {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(_t: Type<T>, _data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(_t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nenum IdlTypeName {\n  EmptyClass = '__IDL_EmptyClass__',\n  UnknownClass = '__IDL_UnknownClass__',\n  BoolClass = '__IDL_BoolClass__',\n  NullClass = '__IDL_NullClass__',\n  ReservedClass = '__IDL_ReservedClass__',\n  TextClass = '__IDL_TextClass__',\n  IntClass = '__IDL_IntClass__',\n  NatClass = '__IDL_NatClass__',\n  FloatClass = '__IDL_FloatClass__',\n  FixedIntClass = '__IDL_FixedIntClass__',\n  FixedNatClass = '__IDL_FixedNatClass__',\n  VecClass = '__IDL_VecClass__',\n  OptClass = '__IDL_OptClass__',\n  RecordClass = '__IDL_RecordClass__',\n  TupleClass = '__IDL_TupleClass__',\n  VariantClass = '__IDL_VariantClass__',\n  RecClass = '__IDL_RecClass__',\n  PrincipalClass = '__IDL_PrincipalClass__',\n  FuncClass = '__IDL_FuncClass__',\n  ServiceClass = '__IDL_ServiceClass__',\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly typeName: IdlTypeName;\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): Uint8Array;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): Uint8Array;\n\n  public abstract checkType(t: Type): Type;\n\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n\n  public _buildTypeTableImpl(_typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  get typeName() {\n    return IdlTypeName.EmptyClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is EmptyClass {\n    return instance.typeName === IdlTypeName.EmptyClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  get typeName() {\n    return IdlTypeName.UnknownClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is UnknownClass {\n    return instance.typeName === IdlTypeName.UnknownClass;\n  }\n\n  public checkType(_t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  get typeName() {\n    return IdlTypeName.BoolClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is BoolClass {\n    return instance.typeName === IdlTypeName.BoolClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): Uint8Array {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  get typeName() {\n    return IdlTypeName.NullClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NullClass {\n    return instance.typeName === IdlTypeName.NullClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(_b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  get typeName() {\n    return IdlTypeName.ReservedClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ReservedClass {\n    return instance.typeName === IdlTypeName.ReservedClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(_x: any): _x is any {\n    return true;\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  get typeName() {\n    return IdlTypeName.TextClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is TextClass {\n    return instance.typeName === IdlTypeName.TextClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.IntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is IntClass {\n    return instance.typeName === IdlTypeName.IntClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.NatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NatClass {\n    return instance.typeName === IdlTypeName.NatClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  get typeName() {\n    return IdlTypeName.FloatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FloatClass {\n    return instance.typeName === IdlTypeName.FloatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return new Uint8Array(buf);\n  }\n\n  public encodeType(): Uint8Array {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = uint8ToDataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedIntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedIntClass {\n    return instance.typeName === IdlTypeName.FixedIntClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedNatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedNatClass {\n    return instance.typeName === IdlTypeName.FixedNatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  get typeName() {\n    return IdlTypeName.VecClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is VecClass<T> {\n    return instance.typeName === IdlTypeName.VecClass;\n  }\n\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(public _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n          ? this._type._bits\n          : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]): Uint8Array {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n\n    if (ArrayBuffer.isView(x)) {\n      // Handle TypedArrays with endianness concerns\n      if (x instanceof Int16Array || x instanceof Uint16Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 2));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int16Array) {\n            buffer.setInt16(i * 2, x[i], true); // true = little-endian\n          } else {\n            buffer.setUint16(i * 2, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof Int32Array || x instanceof Uint32Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 4));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int32Array) {\n            buffer.setInt32(i * 4, x[i], true);\n          } else {\n            buffer.setUint32(i * 4, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 8));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof BigInt64Array) {\n            buffer.setBigInt64(i * 8, x[i], true);\n          } else {\n            buffer.setBigUint64(i * 8, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else {\n        // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n        return concat(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n      }\n    }\n    const buf = new Pipe(new Uint8Array(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Check if we need to swap bytes for endianness\n        const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n        return u16 as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n        return u32 as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8).buffer) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Create a DataView to properly handle endianness\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        // Create result array with correct endianness\n        const result = new Int16Array(len);\n        for (let i = 0; i < len; i++) {\n          // Read each value as little-endian (Candid wire format is little-endian)\n          result[i] = view.getInt16(i * 2, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new Int32Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getInt32(i * 4, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        const bytes = b.read(len * 8);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new BigInt64Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getBigInt64(i * 8, true);\n        }\n        return result as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  get typeName() {\n    return IdlTypeName.OptClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is OptClass<T> {\n    return instance.typeName === IdlTypeName.OptClass;\n  }\n\n  constructor(public _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []): Uint8Array {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    if (t instanceof NullClass) {\n      return [];\n    }\n\n    if (t instanceof ReservedClass) {\n      return [];\n    }\n\n    let wireType = t;\n    // unfold wireType, if needed\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      } else wireType = ty;\n    }\n\n    if (wireType instanceof OptClass) {\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n        case 1: {\n          // Save the current state of the Pipe `b` to allow rollback in case of an error\n          const checkpoint = b.save();\n          try {\n            // Attempt to decode a value using the `_type` of the current instance\n            const v = this._type.decodeValue(b, wireType._type);\n            return [v];\n          } catch (e: any) {\n            // If an error occurs during decoding, restore the Pipe `b` to its previous state\n            b.restore(checkpoint);\n            // Skip the value at the current wire type to advance the Pipe `b` position\n            wireType._type.decodeValue(b, wireType._type);\n            // Return an empty array to indicate a `none` value\n            return [];\n          }\n        }\n        default:\n          throw new Error('Not an option value');\n      }\n    } else if (\n      // this check corresponds to `not (null <: <t>)` in the spec\n      this._type instanceof NullClass ||\n      this._type instanceof OptClass ||\n      this._type instanceof ReservedClass\n    ) {\n      // null <: <t> :\n      // skip value at wire type (to advance b) and return \"null\", i.e. []\n      wireType.decodeValue(b, wireType);\n      return [];\n    } else {\n      // not (null <: t) :\n      // try constituent type\n      const checkpoint = b.save();\n      try {\n        const v = this._type.decodeValue(b, t);\n        return [v];\n      } catch (e: any) {\n        // decoding failed, but this is opt, so return \"null\", i.e. []\n        b.restore(checkpoint);\n        // skip value at wire type (to advance b)\n        wireType.decodeValue(b, t);\n        // return \"null\"\n        return [];\n      }\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.RecordClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is RecordClass {\n    // TupleClass extends RecordClass, so we need to check both here\n    return (\n      instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass\n    );\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>): Uint8Array {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get fieldsAsObject(): Record<number, Type> {\n    const fields: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[idlLabelToId(name)] = ty;\n    }\n    return fields;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  get typeName() {\n    return IdlTypeName.TupleClass;\n  }\n\n  static [Symbol.hasInstance]<T extends any[]>(instance: any): instance is TupleClass<T> {\n    return instance.typeName === IdlTypeName.TupleClass;\n  }\n\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]): Uint8Array {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.VariantClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is VariantClass {\n    return instance.typeName === IdlTypeName.VariantClass;\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n\n  get alternativesAsObject(): Record<number, Type> {\n    const alternatives: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      alternatives[idlLabelToId(name)] = ty;\n    }\n    return alternatives;\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  get typeName() {\n    return IdlTypeName.RecClass;\n  }\n\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined;\n\n  static [Symbol.hasInstance](instance: any): instance is RecClass {\n    return instance.typeName === IdlTypeName.RecClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `μ${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.PrincipalClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is PrincipalClass {\n    return instance.typeName === IdlTypeName.PrincipalClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass extends ConstructType<[PrincipalId, string]> {\n  get typeName() {\n    return IdlTypeName.FuncClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FuncClass {\n    return instance.typeName === IdlTypeName.FuncClass;\n  }\n\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(\n    public argTypes: Type[],\n    public retTypes: Type[],\n    public annotations: string[] = [],\n  ) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [PrincipalId, string] {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) → (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): Uint8Array {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\nexport class ServiceClass extends ConstructType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.ServiceClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ServiceClass {\n    return instance.typeName === IdlTypeName.ServiceClass;\n  }\n\n  public readonly _fields: Array<[string, FuncClass]>;\n  constructor(fields: Record<string, FuncClass>) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n\n  public fieldsAsObject() {\n    const fields: Record<string, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[name] = ty;\n    }\n    return fields;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): Uint8Array {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: Uint8Array): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  resetSubtypeCache();\n  const types = rawTypes.map(t => getType(t));\n  try {\n    const output = retTypes.map((t, i) => {\n      return t.decodeValue(b, types[i]);\n    });\n\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n      types[ind].decodeValue(b, types[ind]);\n    }\n\n    if (b.byteLength > 0) {\n      throw new Error('decode: Left-over bytes');\n    }\n\n    return output;\n  } finally {\n    resetSubtypeCache();\n  }\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func(args: Type[], ret: Type[], annotations: string[] = []): FuncClass {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service(t: Record<string, FuncClass>): ServiceClass {\n  return new ServiceClass(t);\n}\n\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n  private rels: Map<string, Map<string, boolean>>;\n\n  constructor(relations = new Map()) {\n    this.rels = relations;\n  }\n\n  copy(): Relations {\n    const copy = new Map();\n    for (const [key, value] of this.rels.entries()) {\n      const valCopy = new Map(value);\n      copy.set(key, valCopy);\n    }\n    return new Relations(copy);\n  }\n\n  /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n  /// if we don't know yet (`undefined`)\n  known(t1: Type, t2: Type): boolean | undefined {\n    return this.rels.get(t1.name)?.get(t2.name);\n  }\n\n  addNegative(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, false);\n  }\n\n  add(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, true);\n  }\n\n  display(): string {\n    let result = '';\n    for (const [t1, v] of this.rels) {\n      for (const [t2, known] of v) {\n        const subty = known ? ':<' : '!<:';\n        result += `${t1} ${subty} ${t2}\\n`;\n      }\n    }\n    return result;\n  }\n\n  private addNames(t1: string, t2: string, isSubtype: boolean) {\n    const t1Map = this.rels.get(t1);\n    if (t1Map == undefined) {\n      const newMap = new Map();\n      newMap.set(t2, isSubtype);\n      this.rels.set(t1, newMap);\n    } else {\n      t1Map.set(t2, isSubtype);\n    }\n  }\n}\n\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache: Relations = new Relations();\n\n/** Resets the global subtyping cache */\nexport function resetSubtypeCache() {\n  subtypeCache = new Relations();\n}\n\nfunction eqFunctionAnnotations(t1: FuncClass, t2: FuncClass): boolean {\n  const t1Annotations = new Set(t1.annotations);\n  const t2Annotations = new Set(t2.annotations);\n  if (t1Annotations.size !== t2Annotations.size) {\n    return false;\n  }\n  for (const a of t1Annotations) {\n    if (!t2Annotations.has(a)) return false;\n  }\n  return true;\n}\n\nfunction canBeOmmitted(t: Type) {\n  return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nexport function subtype(t1: Type, t2: Type): boolean {\n  const relations = subtypeCache.copy();\n  const isSubtype = subtype_(relations, t1, t2);\n  if (isSubtype) {\n    subtypeCache.add(t1, t2);\n  } else {\n    subtypeCache.addNegative(t1, t2);\n  }\n  return isSubtype;\n}\n\nfunction subtype_(relations: Relations, t1: Type, t2: Type): boolean {\n  if (t1.name === t2.name) return true;\n  const known = relations.known(t1, t2);\n  if (known !== undefined) return known;\n  relations.add(t1, t2);\n\n  if (t2 instanceof ReservedClass) return true;\n  if (t1 instanceof EmptyClass) return true;\n  if (t1 instanceof NatClass && t2 instanceof IntClass) return true;\n  if (t1 instanceof VecClass && t2 instanceof VecClass)\n    return subtype_(relations, t1._type, t2._type);\n  if (t2 instanceof OptClass) return true;\n  if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n    const t1Object = t1.fieldsAsObject;\n    for (const [label, ty2] of t2._fields) {\n      const ty1 = t1Object[idlLabelToId(label)];\n      if (!ty1) {\n        if (!canBeOmmitted(ty2)) return false;\n      } else {\n        if (!subtype_(relations, ty1, ty2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n    if (!eqFunctionAnnotations(t1, t2)) return false;\n    for (let i = 0; i < t1.argTypes.length; i++) {\n      const argTy1 = t1.argTypes[i];\n      if (i < t2.argTypes.length) {\n        if (!subtype_(relations, t2.argTypes[i], argTy1)) return false;\n      } else {\n        if (!canBeOmmitted(argTy1)) return false;\n      }\n    }\n    for (let i = 0; i < t2.retTypes.length; i++) {\n      const retTy2 = t2.retTypes[i];\n      if (i < t1.retTypes.length) {\n        if (!subtype_(relations, t1.retTypes[i], retTy2)) return false;\n      } else {\n        if (!canBeOmmitted(retTy2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n    const t2Object = t2.alternativesAsObject;\n    for (const [label, ty1] of t1._fields) {\n      const ty2 = t2Object[idlLabelToId(label)];\n      if (!ty2) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n    const t1Object = t1.fieldsAsObject();\n    for (const [name, ty2] of t2._fields) {\n      const ty1 = t1Object[name];\n      if (!ty1) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof RecClass) {\n    return subtype_(relations, t1.getType()!, t2);\n  }\n  if (t2 instanceof RecClass) {\n    return subtype_(relations, t1, t2.getType()!);\n  }\n  return false;\n}\n","import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent/index.ts';\nimport { type PollStrategy } from './index.ts';\nimport { type RequestId } from '../request_id.ts';\nimport { ProtocolError, TimeoutWaitingForResponseErrorCode } from '../errors.ts';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    _canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw ProtocolError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(\n          `Failed to retrieve a reply for request after ${count} attempts`,\n          requestId,\n          status,\n        ),\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    _canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw ProtocolError.fromCode(\n        new TimeoutWaitingForResponseErrorCode(\n          `Request timed out after ${timeInMsec} msec`,\n          requestId,\n          status,\n        ),\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n","import { type RequestId } from '../request_id.ts';\nimport { type CreateCertificateOptions, Certificate, lookupResultToBuffer } from '../certificate.ts';\nimport { type Agent, type ReadStateResponse } from '../agent/api.ts';\nimport { Principal } from '@dfinity/principal';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  InvalidReadStateRequestErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  RequestStatusDoneNoReplyErrorCode,\n  UnknownError,\n  UNREACHABLE_ERROR,\n} from '../errors.ts';\n\nexport * as strategy from './strategy.ts';\nimport { defaultStrategy } from './strategy.ts';\nimport { ReadRequestType, type ReadStateRequest } from '../agent/http/types.ts';\nimport { RequestStatusResponseStatus } from '../agent/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\nexport { defaultStrategy } from './strategy.ts';\n\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\n\nexport type PollStrategyFactory = () => PollStrategy;\n\ninterface SignedReadStateRequestWithExpiry extends ReadStateRequest {\n  body: {\n    content: Pick<ReadStateRequest, 'request_type' | 'ingress_expiry'>;\n  };\n}\n\n/**\n * Options for controlling polling behavior\n */\nexport interface PollingOptions {\n  /**\n   * A polling strategy that dictates how much and often we should poll the\n   * read_state endpoint to get the result of an update call.\n   * @default defaultStrategy()\n   */\n  strategy?: PollStrategy;\n\n  /**\n   * Whether to reuse the same signed request for polling or create a new unsigned request each time.\n   * @default false\n   */\n  preSignReadStateRequest?: boolean;\n\n  /**\n   * Optional replacement function that verifies the BLS signature of a certificate.\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * The request to use for polling. If not provided, a new request will be created.\n   * This is only used if `preSignReadStateRequest` is set to false.\n   */\n  request?: ReadStateRequest;\n}\n\nexport const DEFAULT_POLLING_OPTIONS: PollingOptions = {\n  strategy: defaultStrategy(),\n  preSignReadStateRequest: false,\n};\n\n/**\n * Check if an object has a property\n * @param value the object that might have the property\n * @param property the key of property we're looking for\n */\nfunction hasProperty<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, unknown> {\n  return Object.prototype.hasOwnProperty.call(value, property);\n}\n\nfunction isObjectWithProperty<O extends object, P extends string>(\n  value: unknown,\n  property: P,\n): value is O & Record<P, unknown> {\n  return value !== null && typeof value === 'object' && hasProperty(value, property);\n}\n\nfunction hasFunction<O extends object, P extends string>(\n  value: O,\n  property: P,\n): value is O & Record<P, (...args: unknown[]) => unknown> {\n  return hasProperty(value, property) && typeof value[property] === 'function';\n}\n\n/**\n * Check if value is a signed read state request with expiry\n * @param value to check\n */\nfunction isSignedReadStateRequestWithExpiry(\n  value: unknown,\n): value is SignedReadStateRequestWithExpiry {\n  return (\n    isObjectWithProperty(value, 'body') &&\n    isObjectWithProperty(value.body, 'content') &&\n    (value.body.content as { request_type: ReadRequestType }).request_type ===\n      ReadRequestType.ReadState &&\n    isObjectWithProperty(value.body.content, 'ingress_expiry') &&\n    typeof value.body.content.ingress_expiry === 'object' &&\n    value.body.content.ingress_expiry !== null &&\n    hasFunction(value.body.content.ingress_expiry, 'toHash')\n  );\n}\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param options polling options to control behavior\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  options: PollingOptions = {},\n): Promise<{\n  certificate: Certificate;\n  reply: Uint8Array;\n}> {\n  const path = [utf8ToBytes('request_status'), requestId];\n\n  let state: ReadStateResponse;\n  let currentRequest: ReadStateRequest | undefined;\n  const preSignReadStateRequest = options.preSignReadStateRequest ?? false;\n  if (preSignReadStateRequest) {\n    // If preSignReadStateRequest is true, we need to create a new request\n    currentRequest = await constructRequest({\n      paths: [path],\n      agent,\n      pollingOptions: options,\n    });\n    state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  } else {\n    // If preSignReadStateRequest is false, we use the default strategy and sign the request each time\n    state = await agent.readState(canisterId, { paths: [path] });\n  }\n\n  if (agent.rootKey == null) {\n    throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n  }\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify: options.blsVerify,\n  });\n\n  const maybeBuf = lookupResultToBuffer(cert.lookup_path([...path, utf8ToBytes('status')]));\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return {\n        reply: lookupResultToBuffer(cert.lookup_path([...path, 'reply']))!,\n        certificate: cert,\n      };\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing: {\n      // Execute the polling strategy, then retry.\n      const strategy = options.strategy ?? defaultStrategy();\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, {\n        ...options,\n        request: currentRequest,\n      });\n    }\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_code']))!,\n      )[0];\n      const rejectMessage = new TextDecoder().decode(\n        lookupResultToBuffer(cert.lookup_path([...path, 'reject_message']))!,\n      );\n      const errorCodeBuf = lookupResultToBuffer(cert.lookup_path([...path, 'error_code']));\n      const errorCode = errorCodeBuf ? new TextDecoder().decode(errorCodeBuf) : undefined;\n      throw RejectError.fromCode(\n        new CertifiedRejectErrorCode(requestId, rejectCode, rejectMessage, errorCode),\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw UnknownError.fromCode(new RequestStatusDoneNoReplyErrorCode(requestId));\n  }\n  throw UNREACHABLE_ERROR;\n}\n\n// Determine if we should reuse the read state request or create a new one\n// based on the options provided.\n\n/**\n * Constructs a read state request for the given paths.\n * If the request is already signed and has an expiry, it will be returned as is.\n * Otherwise, a new request will be created.\n * @param options The options to use for creating the request.\n * @param options.paths The paths to read from.\n * @param options.agent The agent to use to create the request.\n * @param options.pollingOptions The options to use for creating the request.\n * @returns The read state request.\n */\nexport async function constructRequest(options: {\n  paths: Uint8Array[][];\n  agent: Agent;\n  pollingOptions: PollingOptions;\n}): Promise<ReadStateRequest> {\n  const { paths, agent, pollingOptions } = options;\n  if (pollingOptions.request && isSignedReadStateRequestWithExpiry(pollingOptions.request)) {\n    return pollingOptions.request;\n  }\n  const request = await agent.createReadStateRequest?.(\n    {\n      paths,\n    },\n    undefined,\n  );\n  if (!isSignedReadStateRequestWithExpiry(request)) {\n    throw InputError.fromCode(new InvalidReadStateRequestErrorCode(request));\n  }\n  return request;\n}\n","import {\n  type Agent,\n  type HttpDetailsResponse,\n  isV2ResponseBody,\n  isV3ResponseBody,\n  QueryResponseStatus,\n} from './agent/index.ts';\nimport {\n  CertifiedRejectErrorCode,\n  ExternalError,\n  InputError,\n  MissingCanisterIdErrorCode,\n  MissingRootKeyErrorCode,\n  RejectError,\n  UncertifiedRejectErrorCode,\n  UnexpectedErrorCode,\n  UnknownError,\n} from './errors.ts';\nimport { IDL } from '@dfinity/candid';\nimport { pollForResponse, type PollingOptions, DEFAULT_POLLING_OPTIONS } from './polling/index.ts';\nimport { Principal } from '@dfinity/principal';\nimport { Certificate, type CreateCertificateOptions, lookupResultToBuffer } from './certificate.ts';\nimport { HttpAgent } from './agent/http/index.ts';\nimport { utf8ToBytes } from '@noble/hashes/utils';\n\n/**\n * Configuration to make calls to the Replica.\n */\nexport interface CallConfig {\n  /**\n   * An agent to use in this call, otherwise the actor or call will try to discover the\n   * agent to use.\n   */\n  agent?: Agent;\n\n  /**\n   * Options for controlling polling behavior.\n   */\n  pollingOptions?: PollingOptions;\n\n  /**\n   * The canister ID of this Actor.\n   */\n  canisterId?: string | Principal;\n\n  /**\n   * The effective canister ID. This should almost always be ignored.\n   */\n  effectiveCanisterId?: Principal;\n\n  /**\n   * The nonce to use for this call. This is used to prevent replay attacks.\n   */\n  nonce?: Uint8Array;\n}\n\n/**\n * Configuration that can be passed to customize the Actor behaviour.\n */\nexport interface ActorConfig extends CallConfig {\n  /**\n   * The Canister ID of this Actor. This is required for an Actor.\n   */\n  canisterId: string | Principal;\n\n  /**\n   * An override function for update calls' CallConfig. This will be called on every calls.\n   */\n  callTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * An override function for query calls' CallConfig. This will be called on every query.\n   */\n  queryTransform?(\n    methodName: string,\n    args: unknown[],\n    callConfig: CallConfig,\n  ): Partial<CallConfig> | void;\n\n  /**\n   * Polyfill for BLS Certificate verification in case wasm is not supported\n   */\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n\n  /**\n   * Polling options to use when making update calls. This will override the default DEFAULT_POLLING_OPTIONS.\n   */\n  pollingOptions?: PollingOptions;\n}\n\n// TODO: move this to proper typing when Candid support TypeScript.\n/**\n * A subclass of an actor. Actor class itself is meant to be a based class.\n */\nexport type ActorSubclass<T = Record<string, ActorMethod>> = Actor & T;\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethod<Args extends unknown[] = unknown[], Ret = unknown> {\n  (...args: Args): Promise<Ret>;\n\n  withOptions(options: CallConfig): (...args: Args) => Promise<Ret>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodWithHttpDetails<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{ httpDetails: HttpDetailsResponse; result: Ret }>;\n}\n\n/**\n * An actor method type, defined for each methods of the actor service.\n */\nexport interface ActorMethodExtended<Args extends unknown[] = unknown[], Ret = unknown>\n  extends ActorMethod {\n  (...args: Args): Promise<{\n    certificate?: Certificate;\n    httpDetails?: HttpDetailsResponse;\n    result: Ret;\n  }>;\n}\n\nexport type FunctionWithArgsAndReturn<Args extends unknown[] = unknown[], Ret = unknown> = (\n  ...args: Args\n) => Ret;\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedWithHttpDetails<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodWithHttpDetails<Args, Ret>\n    : never;\n};\n\n// Update all entries of T with the extra information from ActorMethodWithInfo\nexport type ActorMethodMappedExtended<T> = {\n  [K in keyof T]: T[K] extends FunctionWithArgsAndReturn<infer Args, infer Ret>\n    ? ActorMethodExtended<Args, Ret>\n    : never;\n};\n\n/**\n * The mode used when installing a canister.\n */\nexport type CanisterInstallMode =\n  | {\n      reinstall: null;\n    }\n  | {\n      upgrade:\n        | []\n        | [\n            {\n              skip_pre_upgrade: [] | [boolean];\n            },\n          ];\n    }\n  | {\n      install: null;\n    };\n\n/**\n * Internal metadata for actors. It's an enhanced version of ActorConfig with\n * some fields marked as required (as they are defaulted) and canisterId as\n * a Principal type.\n */\ninterface ActorMetadata {\n  service: IDL.ServiceClass;\n  agent?: Agent;\n  config: ActorConfig;\n}\n\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n\nexport interface CreateActorClassOpts {\n  httpDetails?: boolean;\n  certificate?: boolean;\n}\n\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nexport class Actor {\n  /**\n   * Get the Agent class this Actor would call, or undefined if the Actor would use\n   * the default agent (global.ic.agent).\n   * @param actor The actor to get the agent of.\n   */\n  public static agentOf(actor: Actor): Agent | undefined {\n    return actor[metadataSymbol].config.agent;\n  }\n\n  /**\n   * Get the interface of an actor, in the form of an instance of a Service.\n   * @param actor The actor to get the interface of.\n   */\n  public static interfaceOf(actor: Actor): IDL.ServiceClass {\n    return actor[metadataSymbol].service;\n  }\n\n  public static canisterIdOf(actor: Actor): Principal {\n    return Principal.from(actor[metadataSymbol].config.canisterId);\n  }\n\n  public static createActorClass(\n    interfaceFactory: IDL.InterfaceFactory,\n    options?: CreateActorClassOpts,\n  ): ActorConstructor {\n    const service = interfaceFactory({ IDL });\n\n    class CanisterActor extends Actor {\n      [x: string]: ActorMethod;\n\n      constructor(config: ActorConfig) {\n        if (!config.canisterId) {\n          throw InputError.fromCode(new MissingCanisterIdErrorCode(config.canisterId));\n        }\n        const canisterId =\n          typeof config.canisterId === 'string'\n            ? Principal.fromText(config.canisterId)\n            : config.canisterId;\n\n        super({\n          config: {\n            ...DEFAULT_ACTOR_CONFIG,\n            ...config,\n            canisterId,\n          },\n          service,\n        });\n\n        for (const [methodName, func] of service._fields) {\n          if (options?.httpDetails) {\n            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n          }\n          if (options?.certificate) {\n            func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n          }\n\n          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n        }\n      }\n    }\n\n    return CanisterActor;\n  }\n\n  public static createActor<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<T> {\n    if (!configuration.canisterId) {\n      throw InputError.fromCode(new MissingCanisterIdErrorCode(configuration.canisterId));\n    }\n    return new (this.createActorClass(interfaceFactory))(\n      configuration,\n    ) as unknown as ActorSubclass<T>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @deprecated - use createActor with actorClassOptions instead\n   */\n  public static createActorWithHttpDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n  ): ActorSubclass<ActorMethodMappedWithHttpDetails<T>> {\n    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedWithHttpDetails<T>>;\n  }\n\n  /**\n   * Returns an actor with methods that return the http response details along with the result\n   * @param interfaceFactory - the interface factory for the actor\n   * @param configuration - the configuration for the actor\n   * @param actorClassOptions - options for the actor class extended details to return with the result\n   */\n  public static createActorWithExtendedDetails<T = Record<string, ActorMethod>>(\n    interfaceFactory: IDL.InterfaceFactory,\n    configuration: ActorConfig,\n    actorClassOptions: CreateActorClassOpts = {\n      httpDetails: true,\n      certificate: true,\n    },\n  ): ActorSubclass<ActorMethodMappedExtended<T>> {\n    return new (this.createActorClass(interfaceFactory, actorClassOptions))(\n      configuration,\n    ) as unknown as ActorSubclass<ActorMethodMappedExtended<T>>;\n  }\n\n  private [metadataSymbol]: ActorMetadata;\n\n  protected constructor(metadata: ActorMetadata) {\n    this[metadataSymbol] = Object.freeze(metadata);\n  }\n}\n\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types: IDL.Type[], msg: Uint8Array) {\n  const returnValues = IDL.decode(types, msg);\n  switch (returnValues.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return returnValues[0];\n    default:\n      return returnValues;\n  }\n}\n\nconst DEFAULT_ACTOR_CONFIG: Partial<ActorConfig> = {\n  pollingOptions: DEFAULT_POLLING_OPTIONS,\n};\n\nexport type ActorConstructor = new (config: ActorConfig) => ActorSubclass;\n\nexport const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nexport const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\n\nfunction _createActorMethod(\n  actor: Actor,\n  methodName: string,\n  func: IDL.FuncClass,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): ActorMethod {\n  let caller: (options: CallConfig, ...args: unknown[]) => Promise<unknown>;\n  if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.queryTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || new HttpAgent();\n      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n      const arg = IDL.encode(func.argTypes, args);\n\n      const result = await agent.query(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: options.effectiveCanisterId,\n      });\n      const httpDetails = {\n        ...result.httpDetails,\n        requestDetails: result.requestDetails,\n      } as HttpDetailsResponse;\n\n      switch (result.status) {\n        case QueryResponseStatus.Rejected: {\n          const uncertifiedRejectErrorCode = new UncertifiedRejectErrorCode(\n            result.requestId,\n            result.reject_code,\n            result.reject_message,\n            result.error_code,\n            result.signatures,\n          );\n          uncertifiedRejectErrorCode.callContext = {\n            canisterId: cid,\n            methodName,\n            httpDetails,\n          };\n          throw RejectError.fromCode(uncertifiedRejectErrorCode);\n        }\n\n        case QueryResponseStatus.Replied:\n          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n            ? {\n                httpDetails,\n                result: decodeReturnValue(func.retTypes, result.reply.arg),\n              }\n            : decodeReturnValue(func.retTypes, result.reply.arg);\n      }\n    };\n  } else {\n    caller = async (options, ...args) => {\n      // First, if there's a config transformation, call it.\n      options = {\n        ...options,\n        ...actor[metadataSymbol].config.callTransform?.(methodName, args, {\n          ...actor[metadataSymbol].config,\n          ...options,\n        }),\n      };\n\n      const agent = options.agent || actor[metadataSymbol].config.agent || HttpAgent.createSync();\n\n      const { canisterId, effectiveCanisterId, pollingOptions } = {\n        ...DEFAULT_ACTOR_CONFIG,\n        ...actor[metadataSymbol].config,\n        ...options,\n      };\n      const cid = Principal.from(canisterId);\n      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;\n      const arg = IDL.encode(func.argTypes, args);\n\n      const { requestId, response, requestDetails } = await agent.call(cid, {\n        methodName,\n        arg,\n        effectiveCanisterId: ecid,\n        nonce: options.nonce,\n      });\n      let reply: Uint8Array | undefined;\n      let certificate: Certificate | undefined;\n      if (isV3ResponseBody(response.body)) {\n        if (agent.rootKey == null) {\n          throw ExternalError.fromCode(new MissingRootKeyErrorCode());\n        }\n        const cert = response.body.certificate;\n        certificate = await Certificate.create({\n          certificate: cert,\n          rootKey: agent.rootKey,\n          canisterId: Principal.from(canisterId),\n          blsVerify,\n        });\n        const path = [utf8ToBytes('request_status'), requestId];\n        const status = new TextDecoder().decode(\n          lookupResultToBuffer(certificate.lookup_path([...path, 'status'])),\n        );\n\n        switch (status) {\n          case 'replied':\n            reply = lookupResultToBuffer(certificate.lookup_path([...path, 'reply']));\n            break;\n          case 'rejected': {\n            // Find rejection details in the certificate\n            const rejectCode = new Uint8Array(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_code']))!,\n            )[0];\n            const rejectMessage = new TextDecoder().decode(\n              lookupResultToBuffer(certificate.lookup_path([...path, 'reject_message']))!,\n            );\n\n            const error_code_buf = lookupResultToBuffer(\n              certificate.lookup_path([...path, 'error_code']),\n            );\n            const error_code = error_code_buf\n              ? new TextDecoder().decode(error_code_buf)\n              : undefined;\n\n            const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n              requestId,\n              rejectCode,\n              rejectMessage,\n              error_code,\n            );\n            certifiedRejectErrorCode.callContext = {\n              canisterId: cid,\n              methodName,\n              httpDetails: response,\n            };\n            throw RejectError.fromCode(certifiedRejectErrorCode);\n          }\n        }\n      } else if (isV2ResponseBody(response.body)) {\n        // handle v2 response errors by throwing an UpdateCallRejectedError object\n        const { reject_code, reject_message, error_code } = response.body;\n        const certifiedRejectErrorCode = new CertifiedRejectErrorCode(\n          requestId,\n          reject_code,\n          reject_message,\n          error_code,\n        );\n        certifiedRejectErrorCode.callContext = {\n          canisterId: cid,\n          methodName,\n          httpDetails: response,\n        };\n        throw RejectError.fromCode(certifiedRejectErrorCode);\n      }\n\n      // Fall back to polling if we receive an Accepted response code\n      if (response.status === 202) {\n        const pollOptions: PollingOptions = {\n          ...pollingOptions,\n          blsVerify,\n        };\n        // Contains the certificate and the reply from the boundary node\n        const response = await pollForResponse(agent, ecid, requestId, pollOptions);\n        certificate = response.certificate;\n        reply = response.reply;\n      }\n      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n      const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n\n      const httpDetails = { ...response, requestDetails } as HttpDetailsResponse;\n      if (reply !== undefined) {\n        if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n          return {\n            httpDetails,\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeCertificate) {\n          return {\n            certificate,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        } else if (shouldIncludeHttpDetails) {\n          return {\n            httpDetails,\n            result: decodeReturnValue(func.retTypes, reply),\n          };\n        }\n        return decodeReturnValue(func.retTypes, reply);\n      } else if (func.retTypes.length === 0) {\n        return shouldIncludeHttpDetails\n          ? {\n              httpDetails: response,\n              result: undefined,\n            }\n          : undefined;\n      } else {\n        throw UnknownError.fromCode(\n          new UnexpectedErrorCode(\n            `Call was returned undefined, but type [${func.retTypes.map(t => t.display()).join(',')}].`,\n          ),\n        );\n      }\n    };\n  }\n\n  const handler = (...args: unknown[]) => caller({}, ...args);\n  handler.withOptions =\n    (options: CallConfig) =>\n    (...args: unknown[]) =>\n      caller(options, ...args);\n  return handler as ActorMethod;\n}\n"],"names":["idlLabelToId","label","test","num","slice","Number","isSafeInteger","s","array","TextEncoder","encode","h","c","idlHash","IDLTypeIds","magicNumber","zipWith","xs","ys","f","map","x","i","TypeTable","constructor","_typs","_idx","Map","has","obj","this","name","add","type","buf","idx","length","set","push","merge","knot","get","knotIdx","undefined","Error","splice","delete","len","lebEncode","concat","indexOf","typeName","slebEncode","Visitor","visitType","_t","_data","visitPrimitive","t","data","visitEmpty","visitBool","visitNull","visitReserved","visitText","visitNumber","visitInt","visitNat","visitFloat","visitFixedInt","visitFixedNat","visitPrincipal","visitConstruct","visitVec","_ty","visitOpt","visitRecord","_fields","visitTuple","components","fields","ty","visitVariant","visitRec","visitFunc","visitService","IdlTypeName","Type","display","valueToString","toReadableString","buildTypeTable","typeTable","_buildTypeTableImpl","PrimitiveType","checkType","_typeTable","ConstructType","RecClass","getType","encodeType","EmptyClass","Symbol","hasInstance","instance","accept","v","d","covariant","encodeValue","Empty","decodeValue","UnknownClass","b","typeFunc","decodedValue","Object","defineProperty","value","writable","enumerable","configurable","BoolClass","Uint8Array","Bool","safeReadUint8","NullClass","Null","_b","ReservedClass","_x","Reserved","TextClass","byteLength","Text","lebDecode","safeRead","TextDecoder","fatal","decode","IntClass","isInteger","Int","slebDecode","toString","NatClass","BigInt","Nat","FloatClass","_bits","super","ArrayBuffer","view","DataView","setFloat32","setFloat64","opcode","Float32","Float64","bytes","uint8ToDataView","getFloat32","getFloat64","FixedIntClass","min","iexp2","max","ok","writeIntLE","offset","Math","log2","readIntLE","FixedNatClass","writeUIntLE","readUIntLE","VecClass","_type","_blobOptimization","bits","isView","BYTES_PER_ELEMENT","Array","isArray","every","e","message","Int16Array","Uint16Array","buffer","setInt16","setUint16","Int32Array","Uint32Array","setInt32","setUint32","BigInt64Array","BigUint64Array","setBigInt64","setBigUint64","byteOffset","Pipe","write","encoded","opCode","Vector","vec","read","Int8Array","result","getInt16","getInt32","getBigInt64","rets","join","OptClass","Opt","wireType","checkpoint","save","restore","RecordClass","TupleClass","arguments","entries","sort","a","tryAsTuple","res","key","_ref","k","hasOwnProperty","values","_ref2","bufs","_ref3","T","forEach","_ref4","_","Record","_ref5","record","expectedRecordIdx","actualRecordIdx","hash","expectKey","expectType","expectedId","actualId","fieldsAsObject","_ref6","_ref7","_ref8","_ref9","_components","tuple","VariantClass","_ref0","_ref1","Variant","_ref10","variant","wireHash","_ref11","_ref12","alternativesAsObject","alternatives","_id","_counter","fill","decodePrincipalId","PrincipalId","fromUint8Array","PrincipalClass","_isPrincipal","toUint8Array","Principal","toText","FuncClass","argsToString","types","argTypes","retTypes","annotations","_ref13","principal","methodName","canister","method","methodLen","arg","Func","argLen","args","retLen","annLen","anns","encodeAnnotation","tt","subtype","mLen","_ref14","str","ann","ServiceClass","_ref15","func","Service","meths","_ref16","labelBuf","labelLen","_ref17","JSON","stringify","_key","substring","toReadableString_max","magic","table","typs","vals","magicBuffer","rawTable","rawTypes","pipe","prevHash","objectLength","pow","argLength","returnValues","returnValuesLength","annotationLength","servLength","methods","nameLength","funcName","funcType","rawList","readTypeTable","Rec","Nat8","Nat16","Nat32","Nat64","Int8","Int16","Int32","Int64","buildType","entry","Vec","Tuple","rec","typeRef","resetSubtypeCache","output","ind","Unknown","_len","_key2","ret","Relations","relations","rels","copy","valCopy","known","t1","t2","addNegative","addNames","isSubtype","t1Map","newMap","subtypeCache","canBeOmmitted","subtype_","t1Object","ty2","ty1","t1Annotations","Set","t2Annotations","size","eqFunctionAnnotations","argTy1","retTy2","t2Object","defaultStrategy","strategies","async","canisterId","requestId","status","chain","condition","first","once","timeInMsec","Promise","resolve","setTimeout","startingThrottleInMsec","backoffFactor","currentThrottling","backoff","end","Date","now","_canisterId","ProtocolError","fromCode","TimeoutWaitingForResponseErrorCode","timeout","DEFAULT_POLLING_OPTIONS","strategy","preSignReadStateRequest","hasProperty","property","prototype","call","isObjectWithProperty","isSignedReadStateRequestWithExpiry","body","content","request_type","ReadRequestType","ReadState","ingress_expiry","hasFunction","pollForResponse","agent","options","path","utf8ToBytes","state","currentRequest","paths","pollingOptions","request","createReadStateRequest","InputError","InvalidReadStateRequestErrorCode","constructRequest","readState","rootKey","ExternalError","MissingRootKeyErrorCode","cert","Certificate","create","certificate","blsVerify","maybeBuf","lookupResultToBuffer","lookup_path","RequestStatusResponseStatus","Replied","reply","Received","Processing","Rejected","rejectCode","rejectMessage","errorCodeBuf","errorCode","RejectError","CertifiedRejectErrorCode","Done","UnknownError","RequestStatusDoneNoReplyErrorCode","UNREACHABLE_ERROR","metadataSymbol","for","Actor","agentOf","actor","config","interfaceOf","service","canisterIdOf","from","createActorClass","interfaceFactory","IDL","MissingCanisterIdErrorCode","fromText","DEFAULT_ACTOR_CONFIG","httpDetails","ACTOR_METHOD_WITH_HTTP_DETAILS","ACTOR_METHOD_WITH_CERTIFICATE","_createActorMethod","createActor","configuration","createActorWithHttpDetails","createActorWithExtendedDetails","actorClassOptions","metadata","freeze","decodeReturnValue","msg","caller","includes","queryTransform","HttpAgent","cid","query","effectiveCanisterId","requestDetails","QueryResponseStatus","uncertifiedRejectErrorCode","UncertifiedRejectErrorCode","reject_code","reject_message","error_code","signatures","callContext","_len2","callTransform","createSync","ecid","response","nonce","isV3ResponseBody","error_code_buf","certifiedRejectErrorCode","isV2ResponseBody","pollOptions","shouldIncludeHttpDetails","shouldIncludeCertificate","UnexpectedErrorCode","handler","_len3","_key3","withOptions","_len4","_key4"],"sourceRoot":""}